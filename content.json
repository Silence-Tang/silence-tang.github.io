{"meta":{"title":"Silence's Blog","subtitle":"Live for Die","description":"Wir müssen wissen. Wir werden wissen.","author":"Silence Tang","url":"http://silence-tang.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2021-09-05T14:05:00.000Z","updated":"2021-09-05T14:09:28.772Z","comments":true,"path":"categories/index.html","permalink":"http://silence-tang.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-06T04:09:40.391Z","updated":"2021-09-05T14:05:41.733Z","comments":true,"path":"about/index.html","permalink":"http://silence-tang.github.io/about/index.html","excerpt":"","text":"许我一溪风与月，醉里笑看云飞雪。 Silence_ 一、个人简介 🙉 学校：西安电子科技大学 书院：丁香1号书院 学院：计算机科学与技术学院 专业：计算机科学与技术（大数据智能方向） 年级：2019级 政治面貌：入党积极分子 地区：江苏扬州 / 陕西西安&nbsp; 二、联系方式 📱1234567var WaysToContactMe = { phone : \"18252731880\", qq : \"572084089\", wechat : \"tzc572084089\", mail : \"572084089@qq.com\"}; &nbsp; 三、竞赛&amp;活动 🏆 大一学年（2019-2020）—— 综排：86.3（2/457） M2：93.28（2/457） 计科院合唱比赛二等奖（2019.9） 校园马拉松（2019.11） 星火杯校二等奖（2019.12） 书院抗疫征文（2020.3） 院级优秀共青团员（2020.4） 数模校赛一等奖（2020.5） 西电英语写作大赛三等奖（2020.6） 经典诵读大赛优秀奖（2020.7） 深圳杯数模竞赛（2020.8） 2019-2020学年国家奖学金（2020.10）&nbsp; 大二学年（2020-2021）—— 综排： 国庆健步走二等奖（2020.10） 大学生英语竞赛二等奖（2020.11） 校园迷你马拉松（2019.11） 数模国赛省二等奖（2020.12） 大学生数学竞赛三等奖（2020.12） 星火杯校三等奖（2020.12） 书院考前压力团辅（2020.12） 书院征文（2021.1） 统信UOS培训认证（2021.2） 数模美赛M奖（2021.2） 数模校赛一等奖（2020.5） 校运动会入场式方阵+拔河（2021.4） 校园马拉松（2021.5） 西电英语写作大赛二等奖（2021.6） 西电英语阅读大赛特等奖（2021.6）&nbsp; 四、个人技能 ⭐️ 技能 熟练度 技能 熟练度 C语言 ●●●●○○○ HTML/MD ●●●●○○○ Matlab ●●●●●○○ CET4 621 Python ●●●●●○○ CET6 609 Microsoft Office ●●●●○○○ 🎤 ●●●●●●○ &nbsp; 五、CSDN学习 🆒欢迎关注我的CSDN: @XDU_TZC 西电CS课程体系学习经验分享 戳这里 OS上机实验详解 戳这里 计组实验详解 戳这里 数电实验大作业-数字钟设计 戳这里 Python学习-爬虫/数据分析/游戏制作 戳这里 B站清华数据挖掘笔记 戳这里 数学建模相关 戳这里 HTML/CSS/MD相关 戳这里 selenium相关 戳这里 Silence_ © 2021"},{"title":"标签","date":"2021-09-05T14:13:00.000Z","updated":"2021-09-05T14:14:05.742Z","comments":true,"path":"tags/index.html","permalink":"http://silence-tang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vs code实现调试运行HTML文件","slug":"vs code实现调试运行HTML文件","date":"2021-09-06T13:08:00.000Z","updated":"2021-09-06T13:10:46.310Z","comments":true,"path":"2021/09/06/vs code实现调试运行HTML文件/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/vs%20code%E5%AE%9E%E7%8E%B0%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CHTML%E6%96%87%E4%BB%B6/","excerpt":"1.打开vs code 2.用Ctrl+Shift+X打开扩展栏，在输入框中输入”live server”，在下方显示的所有扩展中选择”Live Server”并安装","text":"1.打开vs code 2.用Ctrl+Shift+X打开扩展栏，在输入框中输入”live server”，在下方显示的所有扩展中选择”Live Server”并安装 3.编辑你的html文件 4.将.html文件所在位置另存为工作区 5.方法1：打开左侧边栏的资源管理器（或者用Ctrl+Shift+E快捷呼出），选中要调试运行的.html文件，单击右键选择”Open with Live Server”即可在显示.html在浏览器中展现的结果 6.方法2：点击“运行”（F5），根据自己的需求选择运行环境并选中，即可在不同的浏览器环境中看到运行结果。7.方法3：安装html preview相关的插件并在vs code中实现预览（不建议）","categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://silence-tang.github.io/tags/HTML/"},{"name":"vs code","slug":"vs-code","permalink":"http://silence-tang.github.io/tags/vs-code/"}]},{"title":"Markdown转HTML工具","slug":"Markdown转HTML工具","date":"2021-09-06T13:04:00.000Z","updated":"2021-09-06T13:11:24.443Z","comments":true,"path":"2021/09/06/Markdown转HTML工具/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Markdown%E8%BD%ACHTML%E5%B7%A5%E5%85%B7/","excerpt":"1. MaHua在线markdown编辑器：http://mahua.jser.me/ 效果如下：","text":"1. MaHua在线markdown编辑器：http://mahua.jser.me/ 效果如下： 2. zai17在线markdown编辑器：https://www.zai17.com/md2html/ 效果如下：","categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://silence-tang.github.io/tags/Markdown/"},{"name":"HTML","slug":"HTML","permalink":"http://silence-tang.github.io/tags/HTML/"}]},{"title":"vs code Markdown转HTML","slug":"vs code Markdown转HTML","date":"2021-09-06T13:04:00.000Z","updated":"2021-09-06T13:07:05.746Z","comments":true,"path":"2021/09/06/vs code Markdown转HTML/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/vs%20code%20Markdown%E8%BD%ACHTML/","excerpt":"","text":"1.安装扩展插件”Copy Markdown as HTML” 2.打开.md文件 3.用Ctrl+Shift+P打开命令面板，输入”markdown”，在下拉选项中选择”Markdown: Copy as HTML”，则转换后的.html文本已经存于剪切板中，在新文件中用Ctrl+V即可粘贴.html文件内容","categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://silence-tang.github.io/tags/Markdown/"},{"name":"HTML","slug":"HTML","permalink":"http://silence-tang.github.io/tags/HTML/"},{"name":"vs code","slug":"vs-code","permalink":"http://silence-tang.github.io/tags/vs-code/"}]},{"title":"vs code实现Markdown实时预览","slug":"vs code实现Markdown实时预览","date":"2021-09-06T13:02:00.000Z","updated":"2021-09-06T13:07:03.712Z","comments":true,"path":"2021/09/06/vs code实现Markdown实时预览/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/vs%20code%E5%AE%9E%E7%8E%B0Markdown%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/","excerpt":"vs code实现markdown实时预览的方法如下： 1.打开你的vs code 2.用Ctrl+Shift+X打开扩展栏，在输入框中输入”markdown”，在下方显示的所有扩展中选择”Markdown Preview Enhanced”并安装 3.编辑你的markdown文件","text":"vs code实现markdown实时预览的方法如下： 1.打开你的vs code 2.用Ctrl+Shift+X打开扩展栏，在输入框中输入”markdown”，在下方显示的所有扩展中选择”Markdown Preview Enhanced”并安装 3.编辑你的markdown文件 4.用Ctrl+Shift+P快捷打开命令面板，并输入”markdown”，在下拉选项中选择MPE:打开侧边预览 5.在主界面右侧即可看到markdown的侧边预览效果 6.上图中右上角的三个按钮分别是展示本.md文件中的所有超链接、刷新预览页面、回到预览页面顶部。","categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://silence-tang.github.io/tags/Markdown/"},{"name":"vs code","slug":"vs-code","permalink":"http://silence-tang.github.io/tags/vs-code/"}]},{"title":"关于各种实验","slug":"关于各种实验","date":"2021-09-06T12:59:00.000Z","updated":"2021-09-06T13:00:01.083Z","comments":true,"path":"2021/09/06/关于各种实验/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E5%85%B3%E4%BA%8E%E5%90%84%E7%A7%8D%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"我在CSDN上已经上传了计科操作系统实验、计组实验、电子线路实验I的实验报告及相关资料，可供借鉴。具体链接如下： 1. 操作系统上机实验源码 2. 计组实验源码 3. 电子线路实验I——数字钟设计","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"西电计科课程学习","slug":"西电计科课程学习","date":"2021-09-06T12:50:00.000Z","updated":"2021-09-06T12:54:00.228Z","comments":true,"path":"2021/09/06/西电计科课程学习/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"西电计科课程学习个人简介: 本人是XDU19级CS学生，曾获2019-2020学年国家奖学金，大一学年综评:2/457，M2:2/457。目前在计科大数据与智能方向。 概述： 本文的主要内容是结合本人的一些想法与观点以及优秀学长的学习经验，对西电CS所开设课程分学期进行一个比较清晰而全面详尽的剖析与学习经验&amp;学习技巧分享，希望能够对计科学弟学妹的学习有所帮助。","text":"西电计科课程学习个人简介: 本人是XDU19级CS学生，曾获2019-2020学年国家奖学金，大一学年综评:2/457，M2:2/457。目前在计科大数据与智能方向。 概述： 本文的主要内容是结合本人的一些想法与观点以及优秀学长的学习经验，对西电CS所开设课程分学期进行一个比较清晰而全面详尽的剖析与学习经验&amp;学习技巧分享，希望能够对计科学弟学妹的学习有所帮助。 大一上高数 高等数学这门课非常重要。 首先，在学分方面，高数完爆其他基础课程。在所有的大类基础课中，上下两册高数都是5学分，加起来总共就是10学分，那么想要卷奖学金以及未来希望保研的大一同学们一定要认真踏实地学好这门课，尽量把总评分拉到**90+**。 其次，高数是我们在大学中学习的第一门数学类课程，有着重要的承上启下的作用。高数中学到的微积分的思想以及各种数值计算方法，对以后要学的课程而言有着很大的影响（比如大物的分析与计算过程、信号与系统中需要求解微分方程等等）。 高数能够为你在大学中的数学学习打下一个良好的基础，多学数学永远没错。对于本专业的同学而言，有一个良好的数学基础能让你在未来走得更远，个人的发展上限也能有相应的提升。 高数的学习经验： 认真听课，要把课本 or ppt上的定义、定理等重要内容搞清楚，记牢，且不能混淆概念。 无论是课本上的例题或者是ppt中老师选取的典型题，都要搞懂解题思路与解题步骤。每章的课后习题都要找时间做一遍，尤其是微积分那块，有些技巧只有做了题才能掌握，熟能生巧。对于题目不能光做，还要学会做好总结与错题整理。 期中期末：在已经熟练掌握书本知识以及老师的ppt内容，且将例题、书本课后习题都过了一遍的基础上，需要做几套往年题练练手感，个人建议在考试一周之内做题，不要把做真题的日期拉得离正式考试太远，否则会影响临场手感。如果实在是一周之内没有连续时间去做高数题，可以提前两周找时间做，然后在考试前把真题拿出来再看两眼，过一遍，加深印象。西电的高数出的并不难，只要做到上述几点，80+是没有问题的。只要平时再踏实一点，多付出一点精力，加上临场的小智慧，90+也可以手到擒来。 计算机导论与程序设计基础 这门课是计科专业的第一门程序设计类的基础课程，是非常重要的打基础的课程，因此一定要给予足够的重视。老师会通过学校的 OJ系统定期布置上机练习题供同学们练习，并且会计入总评成绩。个人建议一定要把OJ中的每一个题目都完全地、自主地从0开始写出来，直到最终debug完毕，并且评判为AC。 这门课的重点并不在于编程的理论知识要掌握得多好，而是完完全全地落在上机敲代码的实践之中。不能光听老师讲课，编程语言语法什么的学个大概，关键在于实践巩固。 以前没有接触过编程的同学们可能会在课上或是实际编程时感到吃力，这也很正常，放平心态，多刷OJ题，多debug就好。 有能力并且对ACM等编程类竞赛感兴趣的同学可以加入西电ACM的大家庭，学校的ACM总群：116225686。 Tips: 1.一些入门级的OJ：百练、PAT等，在debug时要利用好搜索引擎。 2.多看相关的书籍，多敲代码！多敲代码！多敲代码！ ※程序设计基础-XDOJ-C源代码 提取码：xw2i 其他基础课（思修军理工图大英） 思修、军理就是背书，结合复习资料复习即可。工图不多说，是一门各凭本事的课，计科专业以后应该也用不到叭。。。大学英语想拿高分很简单，平时不缺勤，认真完成各种任务，做好作业就行。英语的期末不是很难，英语基础较好的同学可以轻松80+，这样下来英语的总评可接近90。 ※2018思修客观题题库 提取码：fwws ※2018思修主观题题库 提取码：2kju ※2019军事理论课程复习资料 提取码：ttbf 推荐微信公众号对策府库，里面涵盖了几乎所有重要课程的练习册答案、MOOC答案等。对策府库交流群：516999193。 大一下Python /JAVAIDE选择 建议使用IDEA(Java)和PyCharm(Python) , 两者都是JetBrains公司的产品，使用西电学生邮箱注册可以免费使用。 课程选择 根据自己的喜好来进行选择吧。 我当时选的是李光夏老师的Python课，感觉老师教的不错，课程内容基本是面向0基础同学设计的，对刚学习py编程语言的同学很友善，课程难度不高。本课程拿高分还是比较简单的，把ppt好好看一遍，记住一些重要的概念如封装、继承等，期末卷子并不难，填空和简答基本是对着ppt出的，后面的手写代码题也是基础内容。 据说教JAVA的王煦老师人不错，和蔼可亲、言语诙谐。 JAVA中重点在于面向对象编程的思想，建议先花点时间看看C++的面向对象程序设计，这样就能很快适应从C编程到JAVA编程。 ※Python程序设计实验源代码 提取码：y345 程序设计基础课程设计 当初老师给了我们9条题目让我们写，最后要设计一个图书管理系统。整体来说并不难，相关代码网上也有很多，重点是要理解算法和自己动手解决bug，而不是只会Ctrl+C Ctrl+V。这门课给分也挺高的（可能也分老师？），基本上题目都做出来了，最后上交课程设计实验报告就有90+。 ※程序设计基础课程设计-源代码 提取码：da52 线性代数 之后机器学习会用到很多，但是这门课学得很浅，而且考察很水，建议找MIT的线性代数课程看一看。中英双语，老师语速很友好，顺便可以练一下听力。 线代有两次小测试，计入总评，要重视一下，似乎占的分值不少。此外，应该还有Matlab上机练习（当时疫情期间不在学校，我们这届似乎没有这一项活动，有点遗憾）如果有同学想用Matlab但是又不想安装，可以使用线上Matlab环境。例如免费的 User.me , 相当于一台装了Matlab的私人云主机，能满足计科学生学习Matlab的基础需求。 在这里安利一下b站杨威老师的满分线性代数课程。如果有老师不给ppt的话，可以靠课本结合该课程进行学习。当时疫情期间可能试卷出的非常非常水，基本能40min交卷，这也让我侥幸拿到了大学里第一次100的课程成绩。 离散数学I 这门课是计科同学们接触到的第一门专业核心课，也是比较重要的一门数学课。这门课的特点是概念非常多，注重逻辑和抽象思维的培养。要想学好这门课，对概念的理解与融会贯通是必不可少的一个环节。我当时是整理了一本笔记来帮助自己理清各个章节的概念与定义的。个人建议把重点的、典型的例题和典型题会做就行，没有必要追求把所有课后习题都做一遍，意义不大。 这门课最后的考试也比较中规中矩，不出偏题怪题，基础掌握好就没啥问题了。ps:打印店的往年题基本上都是诸如14,13年左右的题，做了意义不大，当然买了看看还是可以的。 ※离散数学-个人上机题 提取码：x5g4 ※离散数学-个人上机实验报告（仅供参考） 提取码：e9ks ※离散数学-个人手写笔记 提取码：v6t6 大学雾理I 首先要明确一点，大物其实本质上而言并不难学，不要被外界的风声扰乱自己。 个人觉得学校用的课本写的还是比较好的，结构清晰，内容解释也不啰嗦，基本上是属于言简意赅的那种。上课一定要认真跟着老师的思路走，听不懂的先放下，等课后回去再自己看书看ppt去体会、思考老师课上讲的内容。 习题册一定要认真做，独立完成。遇到不会的题目要对照后面的答案搞懂。西电的大物有个传统，就是选习题册和往年题去考。所以考前一定一定要复习那两本习题册，然后买往年题刷一刷。如果习题册实在有重要的题但却搞不懂的话，背答案也不是不行（这仅仅是为了提高绩点的下下之策）。 ※大物上册-个人手写笔记 提取码：4sb3 近代史纲要 ※近代史纲要笔记-手写 提取码：4efr 大一下暑假——数模国赛培训 ※国赛培训第一阶段培训课件+资料 提取码：h3mv ※国赛培训第一阶段培训作业+源码 提取码：e5j2 ※国赛培训第二阶段培训作业(15A+18A+19C+20深圳杯) 提取码：2yjg 大二上数据结构 这门课是计科本科四大核心课之一，重要性不言而喻。这是对编程能力提升的第二个阶段。一定要掌握好书中写的各种数据结构及算法，核心是搞懂算法的设计思想及其具体的编程实现。 还是那句话，多敲代码！多敲代码！多敲代码！。xdoj上的题还是很好的，每个章节都有对应的题目可供练习，一定要自己动手把每个题都做一遍，不会的要看别人的代码认真学习。 期末： 计科的数据结构期末有机试和笔试。机试是一共四道题，两道AC就机试部分满分，多做还能加分（加到总成绩上）。应该平时把oj上的题都弄明白了也没啥问题。笔试的话，需要找往年题写一写，有一定概率老师会零散地出一点往年题进去。笔试要想考好就需要注重数据结构和算法的理论学习了，当然，笔试也并不难。 这门课挂科率还是挺高的，需要重视。 ※数据结构上机+实验源代码 提取码：h55n 数字电路与逻辑设计（数电） 本课程是一门计算机领域的硬件基础课。因为我们CS专业的学生，不仅要学好软件，对于一些基本的硬件知识也要清楚。 这门课学下来是感觉比较简单的，但是学的知识都很重要，在大二下的数电实验和大三上的微机原理都需要用到这些知识。当时教我们的是张平老师，老师人美心善，上课讲课极其耐心，属于保姆式教学，生怕学习不能掌握，且平时分直接拉满，张老师yyds！ 本课程的重点在于组合&amp;时序逻辑电路的分析与设计。要把书上的典型例子弄懂，把老师强调的重点都认真过一遍，考试也没问题了。我们当时出的试卷似乎量比较大（但好在都是老师讲过的题的变化版，难度不大，平时认真学了就会写），基本上没多少人提前交卷。做题的时候要耐住性子，不慌不忙地进行答题，确保耐心与细致。 ※数电-个人手写笔记 提取码：btgj 电路分析基础 这门课似乎不怎么容易学（可能也分人吧…），至于这课被安排在CS的课程体系中是否合理这件事我们暂且不论。这门课是西电传统课，它能帮助你理解低压电路上的工作原理，为以后的课程打下电路分析方面的基础（尤其是信号和模电）。 当时教我们的是一个老奶奶，师讲的时候思路挺清晰的，就是太快了，学生不容易跟上。学期最后换成了王松林老师，讲得不错，学生能接受。我这门课基本上是自己看书自学的。考试的话，就做做往年题吧，难度属于中档，不简单也不是很难。ps:这课挂的人也比较多，还是花点功夫为好。。。 概率论与数理统计 这可能是大多数计科同学本科阶段学习的最后一门数学课了。这门课最重要的是要把握好贯穿于课程的思维方式。这课里面有些东西很有趣，建议认真听，如果以后往机器学习方向发展，可能会有用到（如贝叶斯分类器，决策树之类的）。当时教我们的是王炳波老师，讲课挺生动有趣的。 期末考试难度适中，建议在考试之前买往年题熟悉熟悉考试的题型，顺便练一下手感。这门课在计算方面要用到不少高数里微积分的计算方法和思维，因此话说回来，还是要在大一打好高数的良好基础。 ※概率论与数理统计-实验报告（仅供参考） 提取码：7xnv ※概率论与数理统计-个人手写笔记 提取码：u7e9 大学雾理II 学习方法和上面讲过的大物I基本类似，不再赘述。 马克思主义基本原理 ※马原手写笔记 提取码： 大二下最难顶的一学期 计算机组织与体系结构（计组） 这个课非常非常的重要，学分是计科专业大学四年里最高的（5.5学分），也主要是对计算机的硬件组成和体系结构进行一个全面的理论讲解，比如冯诺依曼结构、数据的表示、存储结构地址映射与变换、磁盘如何存储数据和寻找数据，CPU流水线等等……并不会涉及到具体的编程内容（例如汇编语言等）。 上课一定要好好听，认真完成老师布置的作业。 要想真的学好这门课，就必须把课本上的知识全部吃透。虽然学这门课的过程还是比较艰辛的，但是最后会发现如果把所学内容划分成一个个小知识点来看，并不很难。基本上只要搞清楚书上讲的基本概念然后在此基础上能做典型题就行。当然，能做到这一点已经非常不容易了，这需要课后花一定量的时间和精力去不断巩固、完善自己的知识体系。 这门课挂科率比较高，据说是每年挂40% 左右的人，但是不要被这个冰冷的数字吓到了。期中期末考试之前，老师会发一个复习提纲，基本上涵盖了考试必考的内容。只要对照提纲认真复习书本和课后题就问题不大。我们今年期末考的算比较容易的，这可能会对后两年出题造成影响qwq。。。 这个课与大三上《微机原理与系统设计》课程紧密联系，偏向于理论上的研究。 在西电学堂上有一套完整的视频讲解，搜索”计算机组织与体系结构”（其实也是上课回放），如果有上课听不懂的地方可以去听。 这门课关键是需要多想，想想为什么要这么设计？与其他方法相比好在哪里？ 这门课还有一个重要思想，在很多时候设计中有 A 方案，也有 B 方案，但是他们都不是最完美的方案，就需要取一个折中的 AB 方案，既有 A 和 B 的优点，在某种程度上也克服了 A 和 B 的缺点。 考研的核心课程，要好好听，不管是保研还是考研都很重要。 ※2021计组期中复习要点（from教研组） ※2021计组期末复习要点（from教研组） 计算机通信与网络（计网） 来自某个学长的建议：“建议看另外一本书籍《计算机网络：自顶向下方法》。建议关注一个知乎用户：车小胖。学习的时候多去问几个为什么，然后把里面得帖子文章都浏览一遍，还是相对而言比较的通俗易懂。因为教科书里面的话比较的严谨，并且经过了字斟句酌，导致经常不说人话。” 这门课的特点是内容巨多无比（教材是佛罗赞的《数据通信与网络》黑皮书，将近700页的字典级课本，要学的差不多有27章），比较繁杂，教材是英文教材的翻译版，总体来看写的还行，不是非常晦涩难懂，只是需要非常静心地去看书。 这门课对学生的要求不是很高，因为内容较多也较分散。建议平时的时候一定要带着做章节习题，不要堆在期末才做，不然没时间。在考试之前一定要对照老师发的复习提纲把书过一遍，一些重要的概念要记住。考试难度可能每年不一样，今年我们考的比较基本，基本上都是把重点考了一遍，只要平时认真学了就没啥事了。最后一个大题和2020年最后一题有些相似，也是子网划分，分配ip，掩码和聚合等东西。 ※2021计网期末复习要点+iPad手写笔记 操作系统（OS） 感觉这门课学起来不是特别难，应该会比计组计网轻松一点。这门课围绕计算机操作系统介绍了作业管理、进程管理、死锁、存储管理、文件管理、设备管理等内容，每一章的逻辑还是比较清晰的。 还是那句话，平时的作业要好好做，基本上和考试题类似，考试题也并不会超出作业的难度。 ※操作系统期末知识点归纳（随笔） 信号与系统（信号） 个人觉得这门课学起来是大二下学期最简单的一门课（可能是因为我感觉这门课偏向于数学吧qwq，就是一些计算，没有多少需要深入分析的东西）。 平时好好听，三本练习册好好做，公式啥的记牢就行，期中期末难度都还行，但今年的期末似乎是近几年最难的一次，不过好在计科老师进行了马里亚纳海沟的海底捞，大家成绩都不低。这门课应该不太容易挂吧（隔壁通院似乎很惨，不说了hhh）。。 我觉得这门课就只要吃透课本即可，不需要费时间去看MOOC啥的（如果觉得学起来吃力就康康咱们学校的MOOC就行辣）。当然学校会要求我们完成MOOC的《信号与系统》、《工程信号与系统》这两门线上课，个人觉得迅速刷完课时然后按时完成单元测试和讨论区任务就行（这就是用来送分的模块）。 学习信号与系统需要有电路分析的简单基础，这门课也是大三开设的数字信号处理的基础课程，为后续做图像处理、机器学习打下了很好的数学基础。 ※信号与系统大作业（仅供参考） 提取码：uhvs 模拟电子技术基础（模电） 这门课也是我觉得计科课程体系中安排得不太合理的一门课（小声），而且难度也比较大（不谈论考试难度，仅课程内容而言），以后如果不从事硬件方向估计不怎么用的到模电叭。。 教我们模电的老师是付少锋老师，功力深厚无比，幽默风趣，能看得出他应该在这方面挺有“才气”的老师，但是他讲课风格比较跳跃，思路比较快，一般的同学比较难以跟上他的节奏。 要想学好这门课，感觉还是以下几个方面：课堂专注、书本认真看（包括新知识的介绍和后面跟着的所有例题）、重点章节的书后习题一定要全部独立写完。一般而言，光靠上课听讲可能不太容易一下子就掌握老师讲的内容，这需要我们回去之后再对照ppt和书本把不懂的东西再看几遍，多看看一定能懂，要相信自己。 估计是因为照顾计科方向的同学，计科院的模电的期中期末考试出的并不难，基本上是填空、简答和计算分析和设计题。填空和简答都是基础性内容，很容易，计算分析设计基本上掌握老师讲的重点例题就行。我们老师考试前跟我们说大概有25分是ppt上的例题，结果确实是这样的，所以童鞋们考前一定要认真听老师嘱咐的话哦~ ps:关于《模拟电子技术基础》，可以在中国大学 MOOC 上搜索”孙肖子 模拟电子技术基础”，讲解的比较细致，可以帮助你理解很多基本概念。提醒一点：这门MOOC的内容组织顺序和计科模电似乎不太一样，因此同学们需要结合自己当前所学章节进行学习。 ※模电期末复习提纲+一些个人笔记 毛概 上课可以选择不听，去做别的事（写作业、抄实验报告、记笔记…）；每节课一定要把到签上，这是平时分的大头子；老师会在期末之前收大家的笔记，要求是纸质笔记，大概只要对着ppt写多一点字写漂亮一点就行；小组活动至少一次，基本就是做ppt上去讲就行了；期末考试是有题库的，选择题可能只考了上面的30%不到，但我们这届简答题是和题库里一样的，反正老师发的题库一定要好好看，尽可能背下来。 ※毛概期末复习资料3套+笔记+简答题整理 提取码：v8kk ※毛概-手写笔记 提取码：isep 关于各种实验（信号数电计组计网OS等） 大二下学期真可谓是西电计科最难熬的一学期，而你的周末也会因为各种实验而被疯狂占用，要提前做好心理准备哦~ 一、电路、信号与系统实验I、II 电路、信号与系统实验I在大二上学期，II在大二下学期。 这门实验课基本上对大家来说问题不大，有手就行。基本上每节课老师会讲一下基本原理和实验步骤然后让大家自主完成实验内容（有的老师会演示一遍，这就很爽~）。只要你认真听了如何进行操作，不手残就能正常做完实验。而且不会的地方也可以小声请教旁边的同学或者直接问老师，老师应该是会提醒你哪里出错了的。 二、数电实验（电子线路实验I） 这个实验课总体来说不是很难，就是教你怎么用Quartus II 9.0这个EDA去设计电路、进行波形仿真和用实验箱进行硬件测试。前几次课只要你搞到实验要用的电路图就行，到了实验室对着原理图画一遍再仿真仿真测试测试就行。最后一次课硬核，我们的任务是设计一个带有时、分、秒计时功能的数字钟，实验从下午15:00一直到晚上21:00，耗时较长，中途可以去吃饭。这个应该是最后的考察内容，各凭本事了，没有啥好的建议。#综合设计——数字钟# 三、计组实验 这门实验课是让我们用Quartus II设计计算机内部的存储器、运算器、节拍脉冲发生电路等等，能够让我们对计组课程内容有一个直观的、感性的了解。 要想很快搞完实验有个Little Trick：在实验室的电脑的C盘里有计组实验所有需要用到的工程文件demo（应该是老师自己做的叭），都能直接用，但是还是建议大家搞清楚这里面涉及到的基本原理和数据的传递模式等。 我当时选到的那个教室的老师特别特别水，基本上给他看一眼实验结果再稍微演示一下操作一下就能走了，别的负责一点的老师可能会出一些新花样，到时候同学之间互相帮助就行。 ps:实验成绩计入计组总成绩。 #计组实验详解# 四、计网实验 这个实验不难，根据老师讲的内容然后对着ppt操作就能完成实验，属于有手就行的实验。 要注意做的时候要耐心细致一点，建议每次都提前在纸上画好自己实验要用到的拓扑结构图，把要用的Interface号和要配置的ip地址、子网掩码、默认网关都写清楚再进行实际的连线和配置操作。 ps:实验成绩计入计网总成绩。 五、OS上机实验 操作系统的上机实验是比较硬核的，需要同学们学习如何用Windows下的VC6.0 / Dev C++ 或者Linux系统进行编程，实现进程通信等内容。本实验一共有六次上机，也可以自己在宿舍提前做，做好了直接过去验收就行。 ps:实验成绩计入操作系统总成绩。 #OS上机详解# 六、计算机组装实习 就上一次课，基本上就是教你怎么拆电脑再装回去以及用光盘安装OS、系统应用软件之类的，实验结束后一周内交报告。 其他一些#全面素质模块化测评实施办法# 提取码：ssyr#M1-M5各模块测评细则# 提取码：q6uu#计算机科学与技术专业培养方案(2019级)# 提取码：bdgw#2017级计科院计算机科学与技术专业推免计算课程列表# 提取码：7ush","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"西电操作系统期末知识点归纳（随笔）","slug":"操作系统期末知识点归纳（随笔）","date":"2021-09-06T12:49:00.000Z","updated":"2021-09-06T12:49:49.492Z","comments":true,"path":"2021/09/06/操作系统期末知识点归纳（随笔）/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3%EF%BC%88%E9%9A%8F%E7%AC%94%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"操作系统","slug":"操作系统","permalink":"http://silence-tang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"西电计网期末复习要点+iPad手写笔记","slug":"计网期末复习要点+iPad手写笔记","date":"2021-09-06T12:49:00.000Z","updated":"2021-09-06T12:50:42.478Z","comments":true,"path":"2021/09/06/计网期末复习要点+iPad手写笔记/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E8%AE%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9+iPad%E6%89%8B%E5%86%99%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://silence-tang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"概率论与数理统计大作业实验报告","slug":"概率论与数理统计大作业实验报告","date":"2021-09-06T12:47:00.000Z","updated":"2021-09-06T12:47:54.247Z","comments":true,"path":"2021/09/06/概率论与数理统计大作业实验报告/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","excerpt":"","text":"","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"http://silence-tang.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}]},{"title":"模电期末复习提纲+一些个人笔记","slug":"模电期末复习提纲+一些个人笔记","date":"2021-09-06T12:47:00.000Z","updated":"2021-09-06T12:48:48.977Z","comments":true,"path":"2021/09/06/模电期末复习提纲+一些个人笔记/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2+%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"模电","slug":"模电","permalink":"http://silence-tang.github.io/tags/%E6%A8%A1%E7%94%B5/"}]},{"title":"数字电路与逻辑设计手写笔记","slug":"数字电路与逻辑设计手写笔记","date":"2021-09-06T12:45:00.000Z","updated":"2021-09-06T12:46:21.051Z","comments":true,"path":"2021/09/06/数字电路与逻辑设计手写笔记/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%99%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"数字电路与逻辑设计","slug":"数字电路与逻辑设计","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"}]},{"title":"美赛论文图表绘制的一些想法","slug":"美赛论文图表绘制的一些想法","date":"2021-09-06T12:43:00.000Z","updated":"2021-09-06T12:43:51.428Z","comments":true,"path":"2021/09/06/美赛论文图表绘制的一些想法/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/","excerpt":"关于图表：一、流程图、框架图、步骤图1.在Our work里，先写一到两段话阐述我们做的工作，然后在下方画一个整个解题的思路流程图(mindmap之类的)，这个图要全面、准确、色彩丰富，能正确反正整个框架思路。 2.在进行某一部分的建模完成后，可以画一个仅关于该部分建模的模型框架图。 3.某个算法执行的步骤流程图。","text":"关于图表：一、流程图、框架图、步骤图1.在Our work里，先写一到两段话阐述我们做的工作，然后在下方画一个整个解题的思路流程图(mindmap之类的)，这个图要全面、准确、色彩丰富，能正确反正整个框架思路。 2.在进行某一部分的建模完成后，可以画一个仅关于该部分建模的模型框架图。 3.某个算法执行的步骤流程图。 E.g.二、示意图：1.直观地展示出文字叙述的内容，起到引人注目的点缀作用的图。这类图片可以通过上网搜索得到，也可以自己运用各种软件手绘，但应注意图中不能出现汉字，且应有必要的、简练的英文文字说明。E.g.2.用以刻画选取的各类指标之间的关系、指标与指标影响的准则之间的关系、准则与考量的最终变量之间的关系（谁决定谁、谁影响谁之类的）的图：这种图没有固定的格式，既可以用画流程图的方式画（例如2018E我画的那个），也可以用类似于环形气泡图的方式画（这种貌似更美观，清晰，圆形给人以视觉上的愉悦感）。E.g.2020E的队伍不约而同都采用了这样的图3.雷达图：直观反映多个事物在多个指标上的对比情况。E.g. 4.折线图：最常用。可以用Matlab画也可以用Excel画，但是都要注意以下几点：①一定要标明坐标轴代表的东西。 ②当一幅图里有多个曲线时，在图例里写清楚曲线分别代表什么。 ③让图整体显得稍微花里胡哨一些，但不要过度。Matlab里的线条粗细不要默认的0.5，改成2看起来比较好，当然也可以换成别的。 ④颜色不要用他默认搞出来的颜色，换成沉稳一些的色调（我可能在放屁，但是默认色有点太明亮，优秀论文里貌似没什么人用默认色）。 ⑤用WPS/Excel画这些统计图有模板可以用，可以弄得花里胡哨，是不错的选择，只用Matlab画省去了把数据粘贴进Excel的过程。E.g.5.矩阵放在表格里然后做成的色阶图，直观地反映出数据代表的事物某方面的程度深浅。 三、其他通过软件分析出来的结果图等等 四、具体问题分析画出来的原理图等等","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"美赛C题相关学习笔记-iPad手写","slug":"美赛C题相关学习笔记-iPad手写","date":"2021-09-06T12:42:00.000Z","updated":"2021-09-06T12:42:57.513Z","comments":true,"path":"2021/09/06/美赛C题相关学习笔记-iPad手写/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E7%BE%8E%E8%B5%9BC%E9%A2%98%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iPad%E6%89%8B%E5%86%99/","excerpt":"","text":"","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"学长美赛经验分享整理-iPad手写","slug":"学长美赛经验分享整理-iPad手写","date":"2021-09-06T12:39:00.000Z","updated":"2021-09-06T13:12:32.389Z","comments":true,"path":"2021/09/06/学长美赛经验分享整理-iPad手写/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E5%AD%A6%E9%95%BF%E7%BE%8E%E8%B5%9B%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E6%95%B4%E7%90%86-iPad%E6%89%8B%E5%86%99/","excerpt":"","text":"","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"美赛优秀论文学习笔记-iPad手写","slug":"美赛优秀论文学习笔记-iPad手写","date":"2021-09-06T12:36:00.000Z","updated":"2021-09-06T13:12:55.396Z","comments":true,"path":"2021/09/06/美赛优秀论文学习笔记-iPad手写/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E7%BE%8E%E8%B5%9B%E4%BC%98%E7%A7%80%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-iPad%E6%89%8B%E5%86%99/","excerpt":"","text":"","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"}]},{"title":"解决国内访问GitHub慢的问题（不用找ip/修改host）","slug":"解决国内访问GitHub慢的问题","date":"2021-09-06T12:19:00.000Z","updated":"2021-09-06T12:34:34.216Z","comments":true,"path":"2021/09/06/解决国内访问GitHub慢的问题/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E8%A7%A3%E5%86%B3%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGitHub%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"前段时间我在网上搜索了一堆关于解决GitHub访问慢，打不开网页等问题的解答，基本上大部分回答都是围绕以下操作进行的： “查询 github.global.ssl.fastly.net 和 github.com 两个地址的最新ip再修改本地host文件，最终在cmd用ipconfig/flushdns刷新dns解析。例如→Github访问慢解决办法”。","text":"前段时间我在网上搜索了一堆关于解决GitHub访问慢，打不开网页等问题的解答，基本上大部分回答都是围绕以下操作进行的： “查询 github.global.ssl.fastly.net 和 github.com 两个地址的最新ip再修改本地host文件，最终在cmd用ipconfig/flushdns刷新dns解析。例如→Github访问慢解决办法”。 但这套操作在我的电脑上似乎并不奏效？？？ 其实，比价不费事的方法就是找个加速器，选一个国外的代理（手动滑稽） 这里推荐一个加速器：Pigcha加速器，官网戳这里 下载之后注册登录可以获得几百M的免费流量（应该足够登一阵子github了）,选择一个延迟相对较小的节点，点击“点我加速”即可实现访问加速。 这时候 奇怪的事情发生了？！ 加速成功之后，推荐大家用Microsoft Edge登github网站（我的Chrome即使加速了也没法稳定地登github），总之，Edge访问github是亲测有效的。 注：Edge有时候也会出现访问不稳定的情况，根据经验应该刷新几次或等一会就好了。**","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://silence-tang.github.io/tags/GitHub/"}]},{"title":"纯手撸GitHub个人主页源码(无框架)","slug":"纯手撸GitHub个人主页源码(无框架)","date":"2021-09-06T12:19:00.000Z","updated":"2021-09-06T12:28:06.613Z","comments":true,"path":"2021/09/06/纯手撸GitHub个人主页源码(无框架)/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E7%BA%AF%E6%89%8B%E6%92%B8GitHub%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E6%BA%90%E7%A0%81(%E6%97%A0%E6%A1%86%E6%9E%B6)/","excerpt":"一开始没接触hexo博客框架时为了搞一个GitHub的主页，现学现用徒手撸了一个初代GitHub个人主页的源码，页面风格比较简单清爽，基本上没有使用花里胡哨的设计，可供HTML初学者参考。 通过写这篇初代个人主页的过程，我初步了解并掌握了一丢丢html/css/js/md相关的知识，感觉这对于我学习爬虫以及后来用hexo搭建博客都有很大帮助。现在把这篇个人主页的html设计源码保存一下，权当留个纪念叭☘️…","text":"一开始没接触hexo博客框架时为了搞一个GitHub的主页，现学现用徒手撸了一个初代GitHub个人主页的源码，页面风格比较简单清爽，基本上没有使用花里胡哨的设计，可供HTML初学者参考。 通过写这篇初代个人主页的过程，我初步了解并掌握了一丢丢html/css/js/md相关的知识，感觉这对于我学习爬虫以及后来用hexo搭建博客都有很大帮助。现在把这篇个人主页的html设计源码保存一下，权当留个纪念叭☘️… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 适应移动端设备的网页浏览 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;!-- 合理设置引入js/css文件的代码位置，防止样式覆盖 --&gt; &lt;!-- 这里用静态方式给出页面的css样式，也可以用link链接.css文件 --&gt; &lt;!-- 引入看板娘css文件 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 引入font-awesome字体 --&gt; &lt;!-- &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\"/&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; /* 里面的代码应符合css格式规范 */ /* 页面整体样式 */ html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0}body{font-family:Helvetica,arial,freesans,clean,sans-serif;font-size:16px;line-height:1.6;color:#333;padding:20px;max-width:960px;margin:0 auto}body&gt;*:first-child{margin-top:0 !important}body&gt;*:last-child{margin-bottom:0 !important}p,blockquote,ul,ol,dl,table,pre{margin:15px 0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased}h1 tt,h1 code,h2 tt,h2 code,h3 tt,h3 code,h4 tt,h4 code,h5 tt,h5 code,h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}body&gt;h2:first-child,body&gt;h1:first-child,body&gt;h1:first-child+h2,body&gt;h3:first-child,body&gt;h4:first-child,body&gt;h5:first-child,body&gt;h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1+p,h2+p,h3+p,h4+p,h5+p,h6+p{margin-top:10px}a{color:#4183c4;text-decoration:none}a:hover{text-decoration:underline}ul,ol{padding-left:30px}ul li&gt;:first-child,ol li&gt;:first-child,ul li ul:first-of-type,ol li ol:first-of-type,ul li ol:first-of-type,ol li ul:first-of-type{margin-top:0}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt&gt;:first-child{margin-top:0}dl dt&gt;:last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd&gt;:first-child{margin-top:0}dl dd&gt;:last-child{margin-bottom:0}pre,code,tt{font-size:12px;font-family:Consolas,\"Liberation Mono\",Courier,monospace}code,tt{margin:0;padding:0;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre&gt;code{margin:0;padding:0;white-space:pre;border:0;background:transparent}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:0}blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777}blockquote&gt;:first-child{margin-top:0}blockquote&gt;:last-child{margin-bottom:0}hr{clear:both;margin:15px 0;height:0;overflow:hidden;border:0;background:transparent;border-bottom:4px solid #ddd;padding:0}table th{font-weight:bold}table th,table td{border:1px solid #ccc;padding:6px 13px}table tr{border-top:1px solid #ccc;background-color:#fff}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%} body { background-color:#e4f6ff } /* 动画画布样式 */ canvas{ position: static; width: 100%; height: 600px; background: #f4fffe; } /* 设置页面右侧滚动条样式 */ /* 滚动条凹槽的颜色，还可以设置边框属性 */ ::-webkit-scrollbar-track-piece { background-color:#c8ebff; } /* 滚动条的宽高 */ ::-webkit-scrollbar { width:15px; height:10px; } /* 滚动条内部小滑块 */ ::-webkit-scrollbar-thumb { background-color:#0d71c4; background-clip:padding-box; min-height:28px; background-image: -webkit-linear-gradient(45deg, rgb(71, 227, 255) 25%, transparent 30%,transparent 70%, rgba(27, 73, 173, 0.979) 25%); } ::-webkit-scrollbar-thumb:hover { background-color:rgb(5, 155, 255); } &lt;/style&gt; &lt;title&gt;Silence_Tang | 凛冬散尽，星河长明。&lt;/title&gt; &lt;link rel=\"shortcut icon\" href=\"https://z3.ax1x.com/2021/07/18/W8UfJJ.png\" type=\"image/x-icon\"&gt; &lt;link rel=\"icon\" href=\"https://z3.ax1x.com/2021/07/18/W8UfJJ.png\" type=\"image/x-icon\"&gt; &lt;link rel=\"apple-touch-icon\" href=\"https://z3.ax1x.com/2021/07/18/W8UfJJ.png\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入人物动画js --&gt; &lt;script src=\"https://www.html5tricks.com/demo/html5-person-joint/js/index.js\"&gt;&lt;/script&gt; &lt;!-- 引入不蒜子计数 --&gt; &lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; &lt;!-- 引入旋转花瓣加载特效 --&gt; &lt;center&gt; 浏览量：&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;i class=\"fa fa-spinner fa-spin\"&gt;&lt;/i&gt;&lt;/span&gt;👀 | 访客数：&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;i class=\"fa fa-spinner fa-spin\"&gt;&lt;/i&gt;&lt;/span&gt;👦 &lt;/center&gt; &lt;!-- 修正计数初始值 --&gt; &lt;!-- &lt;script&gt; $(document).ready(function() { var int = setinterval(fixcount, 50); // 50ms周期检测函数 var countoffset = 1000; // 初始化首次数据 function fixcount() { $(\"#busuanzi_value_site_pv\").html(parseint($(\"#busuanzi_value_site_pv\").html()) + countoffset); clearinterval(int); $(\"#busuanzi_value_site_uv\").html(parseint($(\"#busuanzi_value_site_uv\").html()) + countoffset); // 加上初始数据 clearinterval(int); // 停止检测 } }); &lt;/script&gt; --&gt; &lt;center&gt;&lt;font size=8&gt;&lt;font color=#00BFFF&gt;↓&lt;/font&gt;&lt;font color=#1E90FF&gt;↓&lt;/font&gt;&lt;font color=#00BFFF&gt;↓&lt;/font&gt;&lt;/font&gt;&lt;/center&gt; &lt;hr&gt; &lt;div style=\"float:left;\"&gt;&lt;font size=4&gt;Hello guys, welcom to my world !&lt;/font&gt;&lt;/div&gt;&lt;!-- 左右浮动显示，使同一行文字部分居左部分居右 --&gt; &lt;div style=\"float:right;\"&gt;&lt;font size=4&gt;&lt;a href=\"https://github.com/Silence-Tang\"&gt;GitHub主页&lt;/a&gt;&lt;/font&gt;&lt;/div&gt; &lt;div align=\"center\"&gt;&lt;img src=\"https://z3.ax1x.com/2021/07/18/W8NOvq.jpg\" alt=\"BG1\" /&gt;&lt;/div&gt; &lt;center&gt;&lt;font size=8 color=#1E90FF&gt;Si&lt;/font&gt;&lt;font size=8 color=#00BFFF&gt;len&lt;/font&gt;&lt;font size=8 color=#00FFF&gt;ce&lt;/font&gt;&lt;font size=8 color=#00FA9A&gt;_&lt;/font&gt;&lt;/center&gt; &lt;center&gt;&lt;font size=5&gt;许我一溪风与月，醉里笑看云飞雪。&lt;/font&gt;&lt;/center&gt; &lt;p&gt;&lt;img src=\"https://z3.ax1x.com/2021/07/18/W8U954.jpg\" alt=\"BG2\" /&gt;&lt;/p&gt; &lt;h1&gt;一、个人简介 🙉&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt; &lt;p&gt;&lt;img align=\"right\" width=200 height=200 src=\"https://z3.ax1x.com/2021/07/18/W8UfJJ.png\"&gt;&lt;/p&gt; &lt;ul&gt;&lt;!--无序列表--&gt; &lt;font size=3&gt; &lt;li&gt;学校：西安电子科技大学&lt;/li&gt; &lt;li&gt;书院：丁香1号书院&lt;/li&gt; &lt;li&gt;学院：计算机科学与技术学院&lt;/li&gt; &lt;li&gt;专业：计算机科学与技术（普通方向）&lt;/li&gt; &lt;li&gt;年级：2019级&lt;/li&gt; &lt;li&gt;政治面貌：入党积极分子&lt;/li&gt; &lt;li&gt;地区：江苏扬州 / 陕西西安&lt;/li&gt; &lt;/font&gt; &lt;/ul&gt; &lt;h1&gt;二、联系方式 📱&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt;&lt;pre&gt; &lt;!--被包围在 pre 元素中的文本通常会保留空格和换行符--&gt;&lt;code class=\"javascript\"&gt;&lt;font size=3 color=#000080&gt;var WaysToContactMe = { phone : \"18252731880\", qq : \"572084089\", wechat : \"tzc572084089\", mail : \"572084089@qq.com\"};&lt;/font&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;三、竞赛&amp;amp;活动 🏆&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt; &lt;ul&gt;&lt;!--加&lt;ul&gt;可以使带有·的行向右缩进一点--&gt; &lt;li&gt; &lt;!-- &lt;strong&gt;是加粗 --&gt; &lt;p&gt;&lt;strong&gt;大一学年（2019-2020）—— 综排：86.3（2/457） M2：93.28（2/457）&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;1. 计科院合唱比赛二等奖（2019.9）&lt;/em&gt;&lt;/p&gt; &lt;!-- &lt;em&gt;是斜体 --&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;2. 校园马拉松（2019.11）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;3. 星火杯校二等奖（2019.12）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;4. 书院抗疫征文（2020.3）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;5. 院级优秀共青团员（2020.4）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;6. 数模校赛一等奖（2020.5）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;7. 西电英语写作大赛三等奖（2020.6）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;8. 经典诵读大赛优秀奖（2020.7）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;9. 深圳杯数模竞赛（2020.8）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;2019-2020学年国家奖学金（2020.10）&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;大二学年（2020-2021）—— 综排：&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;1. 国庆健步走二等奖（2020.10）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;2. 大学生英语竞赛二等奖（2020.11）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;3. 校园迷你马拉松（2019.11）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;4. 数模国赛省二等奖（2020.12）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;5. 大学生数学竞赛三等奖（2020.12）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;6. 星火杯校三等奖（2020.12）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;7. 书院考前压力团辅（2020.12）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;8. 书院征文（2021.1）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;9. 统信UOS培训认证（2021.2）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;10.数模美赛M奖（2021.2）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;11.校运动会入场式方阵+拔河（2021.4）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;12.校园马拉松（2021.5）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;13.西电英语写作大赛二等奖（2021.6）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;em&gt;14.西电英语阅读大赛特等奖（2021.6）&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;2019-2020学年（2020.10）&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;四、个人技能 ⭐️&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt; &lt;!--width:num值越小表格越靠右，反之靠左--&gt; &lt;div style=\"margin:0 auto;width:400px\"&gt; &lt;table align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th align=\"center\"&gt;技能&lt;/th&gt; &lt;th align=\"center\"&gt;熟练度&lt;/th&gt; &lt;th align=\"center\"&gt;技能&lt;/th&gt; &lt;th align=\"center\"&gt;熟练度&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;C语言&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●●○○&lt;/td&gt; &lt;td align=\"center\"&gt;HTML/CSS/MD&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●○○○&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;Matlab&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●●○○&lt;/td&gt; &lt;td align=\"center\"&gt;CET4&lt;/td&gt; &lt;td align=\"center\"&gt;621&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;Python&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●○○○&lt;/td&gt; &lt;td align=\"center\"&gt;CET6&lt;/td&gt; &lt;td align=\"center\"&gt;609&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;Microsoft Office&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●○○○&lt;/td&gt; &lt;td align=\"center\"&gt;🎤&lt;/td&gt; &lt;td align=\"center\"&gt;●●●●●●○&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;h1&gt;五、课程学习 🆒&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt; &lt;!--width:num值越小表格越靠右，反之靠左--&gt; &lt;div style=\"margin:0 auto;width:920px\"&gt; &lt;table align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th align=\"center\"&gt;专业核心课&lt;/th&gt; &lt;th align=\"center\"&gt;学分绩一览&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td align=\"center\"&gt; &lt;!-- 引入echarts.js --&gt; &lt;script src=\"https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\"&gt;&lt;/script&gt; &lt;!--雷达图--&gt; &lt;div id=\"radar\" style=\"width: 430px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var myChart = echarts.init(document.getElementById('radar')); var option = { tooltip: { trigger: 'item', showContent: true }, backgroundColor: '#e4f6ff', color: ['#FF0000','#00BFFF'], title: { }, legend: { data: ['最高', '个人'] }, radar: { indicator: [ { name: '计算机组成与体系结构', max: 100}, { name: '数据结构', max: 100}, { name: '离散数学', max: 100}, { name: '计算机网络', max: 100}, { name: '操作系统', max: 100}, ] }, series: [{ name: '最高分 vs 个人得分', type: 'radar', data: [ { value: [97, 100, 100, 96, 95], name: '最高' }, { value: [91, 84, 95, 94, 93], name: '个人' } ] }] }; myChart.setOption(option); &lt;/script&gt; &lt;/td&gt; &lt;td align=\"center\"&gt; &lt;!--折线图--&gt; &lt;div id=\"line\" style=\"width: 430px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var myChart = echarts.init(document.getElementById('line')); var option = { legend: {}, tooltip: { trigger: 'axis', showContent: true }, title: { }, backgroundColor: '#e4f6ff', color: ['#00CED1','#1E90FF'], dataset: { source: [ ['项目', '大一上', '大一下', '大二上', '大二下'], ['M2科目', 86.30, 91.28, 90.87, 91.99], ['保研科目', 88.47, 91.55, 91.41, 91.65], ] }, xAxis: {type: 'category'}, yAxis: {gridIndex: 0, min: 86, max: 93}, grid: {top: '15%'}, //调整折线图主体的纵向占比 series: [ {type: 'line', smooth: true, seriesLayoutBy: 'row'}, {type: 'line', smooth: true, seriesLayoutBy: 'row'}, ] }; myChart.setOption(option); &lt;/script&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;li&gt;&lt;strong&gt;&lt;font size=3&gt;附:计科院2017级计算机科学与技术专业推免计算课程列表 &lt;a href=\"https://pan.baidu.com/s/1xm5kaYdg5GyISvA7tX3DqA\"&gt;详情&lt;/a&gt; 提取码：ienk&lt;/font&gt;&lt;/strong&gt;&lt;/li&gt; &lt;p&gt;&lt;li&gt;&lt;strong&gt;&lt;font size=3&gt;附:推免计算课程学分占比（前4学期）：&lt;/font&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/p&gt; &lt;!-- 饼图 --&gt; &lt;!--width:num值越小表格越靠右，反之靠左--&gt; &lt;div style=\"margin:0 auto;width:600px\"&gt; &lt;div id=\"main\" style=\"width:600px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var myChart = echarts.init(document.getElementById('main')); var option = { tooltip: { trigger: 'item', showContent: true }, //设置图表dom的颜色与页面背景一致 backgroundColor: '#e4f6ff', series: [ { type: 'pie', radius: '65%', // 饼图的半径 外半径为可视区尺寸(容器高宽中较小一项)的80%长度。 data:[ // 数据数组 name为数据项名称 value为数据项值 {value:17, name:'大一上'}, {value:23, name:'大一下'}, {value:22, name:'大二上'}, {value:22, name:'大二下'}, ], label:{ normal:{ show:true, position:'outer', //标签的位置 textStyle : { fontWeight : 600 , fontSize : 18 //文字的字体大小 }, formatter:'{d}%' //设置百分比 } }, }] }; myChart.setOption(option); &lt;/script&gt; &lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;&lt;font size=3&gt;欢迎关注我的CSDN: &lt;a href=\"https://blog.csdn.net/qq_45717425?spm=1001.2101.3001.5343\"&gt;@XDU_TZC&lt;/a&gt; || GitHub:&lt;a href=\"https://github.com/Silence-Tang\"&gt;@Slience-Tang&lt;/a&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;西电CS课程体系学习经验分享 &lt;a href=\"https://blog.csdn.net/qq_45717425/article/details/114377616\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;li&gt;OS上机实验详解 &lt;a href=\"https://blog.csdn.net/qq_45717425/category_11180081.html?spm=1001.2014.3001.5482\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;li&gt;计组实验详解 &lt;a href=\"https://blog.csdn.net/qq_45717425/category_11206890.html\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;li&gt;数电实验大作业-数字钟设计 &lt;a href=\"https://blog.csdn.net/qq_45717425/article/details/118466655\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;li&gt;HTML/CSS/MD相关 &lt;a href=\"https://blog.csdn.net/qq_45717425/category_11219736.html\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;li&gt;数学建模学习 &lt;a href=\"https://blog.csdn.net/qq_45717425/category_11225058.html\"&gt;戳这里&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;六、其他&lt;/h1&gt; &lt;hr style=\"background: #3694f9;height:2px;border:none;\"&gt;&lt;pre&gt; &lt;!--被包围在 pre 元素中的文本通常会保留空格和换行符--&gt;&lt;code class=\"javascript\"&gt;&lt;font size=3 color=#000080&gt;var Others = { NetEaseCloudMusic : \"&lt;a href=\" \"&gt;@__清晖引暮色c&lt;/a&gt;\", ZhiHu : \"&lt;a href=\" \"&gt;@Twilight风弦&lt;/a&gt;\",};&lt;/font&gt;&lt;/code&gt;&lt;/pre&gt; &lt;!-- 脚注 --&gt; &lt;div id=\"footer\"&gt; &lt;center&gt; &lt;font size=4&gt;Copyright © 2021 &lt;font color=#1E90FF&gt;Si&lt;/font&gt;&lt;font color=#00BFFF&gt;len&lt;/font&gt;&lt;font color=#00FFF&gt;ce&lt;/font&gt;&lt;font color=#00FA9A&gt;_&lt;/font&gt;&lt;/font&gt; &lt;/center&gt; &lt;br&gt; &lt;/div&gt; &lt;!-- 插入底部动画 --&gt; &lt;p&gt;&lt;i&gt;&lt;font color=#1E90FF&gt;Actually, This Is A Pool Full of Magic Fish...&lt;/font&gt;&lt;/i&gt;&lt;/p&gt; &lt;div id=\"fish-container\" class=\"container\"&gt;&lt;/div&gt; &lt;!-- 引入fish.js文件 --&gt; &lt;!-- &lt;script src=\"https://blog-static.cnblogs.com/files/blogs/695826/fish.js\"&gt;&lt;/script&gt; --&gt; &lt;!-- 博客园指定有什么大病...引用不了js，404了 --&gt; &lt;script type=\"text/javascript\"&gt; var RENDERER = { POINT_INTERVAL : 5, FISH_COUNT : 3, MAX_INTERVAL_COUNT : 50, INIT_HEIGHT_RATE : 0.5, THRESHOLD : 50, init : function(){ this.setParameters(); this.reconstructMethods(); this.setup(); this.bindEvent(); this.render(); }, setParameters : function(){ this.$window = $(window); this.$container = $('#fish-container'); this.$canvas = $('&lt;canvas /&gt;'); this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d'); this.points = []; this.fishes = []; this.watchIds = []; }, createSurfacePoints : function(){ var count = Math.round(this.width / this.POINT_INTERVAL); this.pointInterval = this.width / (count - 1); this.points.push(new SURFACE_POINT(this, 0)); for(var i = 1; i &lt; count; i++){ var point = new SURFACE_POINT(this, i * this.pointInterval), previous = this.points[i - 1]; point.setPreviousPoint(previous); previous.setNextPoint(point); this.points.push(point); } }, reconstructMethods : function(){ this.watchWindowSize = this.watchWindowSize.bind(this); this.jdugeToStopResize = this.jdugeToStopResize.bind(this); this.startEpicenter = this.startEpicenter.bind(this); this.moveEpicenter = this.moveEpicenter.bind(this); this.reverseVertical = this.reverseVertical.bind(this); this.render = this.render.bind(this); }, setup : function(){ this.points.length = 0; this.fishes.length = 0; this.watchIds.length = 0; this.intervalCount = this.MAX_INTERVAL_COUNT; this.width = this.$container.width(); this.height = this.$container.height(); this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500; this.$canvas.attr({width : this.width, height : this.height}); this.reverse = false; this.fishes.push(new FISH(this)); this.createSurfacePoints(); }, watchWindowSize : function(){ this.clearTimer(); this.tmpWidth = this.$window.width(); this.tmpHeight = this.$window.height(); this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL)); }, clearTimer : function(){ while(this.watchIds.length &gt; 0){ clearTimeout(this.watchIds.pop()); } }, jdugeToStopResize : function(){ var width = this.$window.width(), height = this.$window.height(), stopped = (width == this.tmpWidth &amp;&amp; height == this.tmpHeight); this.tmpWidth = width; this.tmpHeight = height; if(stopped){ this.setup(); } }, bindEvent : function(){ this.$window.on('resize', this.watchWindowSize); this.$container.on('mouseenter', this.startEpicenter); this.$container.on('mousemove', this.moveEpicenter); this.$container.on('click', this.reverseVertical); }, getAxis : function(event){ var offset = this.$container.offset(); return { x : event.clientX - offset.left + this.$window.scrollLeft(), y : event.clientY - offset.top + this.$window.scrollTop() }; }, startEpicenter : function(event){ this.axis = this.getAxis(event); }, moveEpicenter : function(event){ var axis = this.getAxis(event); if(!this.axis){ this.axis = axis; } this.generateEpicenter(axis.x, axis.y, axis.y - this.axis.y); this.axis = axis; }, generateEpicenter : function(x, y, velocity){ if(y &lt; this.height / 2 - this.THRESHOLD || y &gt; this.height / 2 + this.THRESHOLD){ return; } var index = Math.round(x / this.pointInterval); if(index &lt; 0 || index &gt;= this.points.length){ return; } this.points[index].interfere(y, velocity); }, reverseVertical : function(){ this.reverse = !this.reverse; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].reverseVertical(); } }, controlStatus : function(){ for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateSelf(); } for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateNeighbors(); } if(this.fishes.length &lt; this.fishCount){ if(--this.intervalCount == 0){ this.intervalCount = this.MAX_INTERVAL_COUNT; this.fishes.push(new FISH(this)); } } }, render : function(){ requestAnimationFrame(this.render); this.controlStatus(); this.context.clearRect(0, 0, this.width, this.height); this.context.fillStyle = 'hsl(0, 0%, 95%)'; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].render(this.context); } this.context.save(); this.context.globalCompositeOperation = 'xor'; this.context.beginPath(); this.context.moveTo(0, this.reverse ? 0 : this.height); for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].render(this.context); } this.context.lineTo(this.width, this.reverse ? 0 : this.height); this.context.closePath(); this.context.fill(); this.context.restore(); } }; var SURFACE_POINT = function(renderer, x){ this.renderer = renderer; this.x = x; this.init(); }; SURFACE_POINT.prototype = { SPRING_CONSTANT : 0.03, SPRING_FRICTION : 0.9, WAVE_SPREAD : 0.3, ACCELARATION_RATE : 0.01, init : function(){ this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE; this.height = this.initHeight; this.fy = 0; this.force = {previous : 0, next : 0}; }, setPreviousPoint : function(previous){ this.previous = previous; }, setNextPoint : function(next){ this.next = next; }, interfere : function(y, velocity){ this.fy = this.renderer.height * this.ACCELARATION_RATE * ((this.renderer.height - this.height - y) &gt;= 0 ? -1 : 1) * Math.abs(velocity); }, updateSelf : function(){ this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height); this.fy *= this.SPRING_FRICTION; this.height += this.fy; }, updateNeighbors : function(){ if(this.previous){ this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height); } if(this.next){ this.force.next = this.WAVE_SPREAD * (this.height - this.next.height); } }, render : function(context){ if(this.previous){ this.previous.height += this.force.previous; this.previous.fy += this.force.previous; } if(this.next){ this.next.height += this.force.next; this.next.fy += this.force.next; } context.lineTo(this.x, this.renderer.height - this.height); } }; var FISH = function(renderer){ this.renderer = renderer; this.init(); }; FISH.prototype = { GRAVITY : 0.4, init : function(){ this.direction = Math.random() &lt; 0.5; this.x = this.direction ? (this.renderer.width + this.renderer.THRESHOLD) : -this.renderer.THRESHOLD; this.previousY = this.y; this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1); if(this.renderer.reverse){ this.y = this.getRandomValue(this.renderer.height * 1 / 10, this.renderer.height * 4 / 10); this.vy = this.getRandomValue(2, 5); this.ay = this.getRandomValue(0.05, 0.2); }else{ this.y = this.getRandomValue(this.renderer.height * 6 / 10, this.renderer.height * 9 / 10); this.vy = this.getRandomValue(-5, -2); this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; this.theta = 0; this.phi = 0; }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, reverseVertical : function(){ this.isOut = !this.isOut; this.ay *= -1; }, controlStatus : function(context){ this.previousY = this.y; this.x += this.vx; this.y += this.vy; this.vy += this.ay; if(this.renderer.reverse){ if(this.y &gt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy -= this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(0.05, 0.2); } this.isOut = false; } }else{ if(this.y &lt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy += this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; } } if(!this.isOut){ this.theta += Math.PI / 20; this.theta %= Math.PI * 2; this.phi += Math.PI / 30; this.phi %= Math.PI * 2; } this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY); if(this.vx &gt; 0 &amp;&amp; this.x &gt; this.renderer.width + this.renderer.THRESHOLD || this.vx &lt; 0 &amp;&amp; this.x &lt; -this.renderer.THRESHOLD){ this.init(); } }, render : function(context){ context.save(); context.translate(this.x, this.y); context.rotate(Math.PI + Math.atan2(this.vy, this.vx)); context.scale(1, this.direction ? 1 : -1); context.beginPath(); context.moveTo(-30, 0); context.bezierCurveTo(-20, 15, 15, 10, 40, 0); context.bezierCurveTo(15, -10, -20, -15, -30, 0); context.fill(); context.save(); context.translate(40, 0); context.scale(0.9 + 0.2 * Math.sin(this.theta), 1); context.beginPath(); context.moveTo(0, 0); context.quadraticCurveTo(5, 10, 20, 8); context.quadraticCurveTo(12, 5, 10, 0); context.quadraticCurveTo(12, -5, 20, -8); context.quadraticCurveTo(5, -10, 0, 0); context.fill(); context.restore(); context.save(); context.translate(-3, 0); context.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)); context.beginPath(); if(this.renderer.reverse){ context.moveTo(5, 0); context.bezierCurveTo(10, 10, 10, 30, 0, 40); context.bezierCurveTo(-12, 25, -8, 10, 0, 0); }else{ context.moveTo(-5, 0); context.bezierCurveTo(-10, -10, -10, -30, 0, -40); context.bezierCurveTo(12, -25, 8, -10, 0, 0); } context.closePath(); context.fill(); context.restore(); context.restore(); this.controlStatus(context); } }; $(function(){ RENDERER.init(); }); &lt;/script&gt; &lt;!-- 下面是回到顶部代码--&gt; &lt;div style=\"float:left\"&gt; &lt;div id=\"totop\"&gt; &lt;a href=\"javascript:;\" id=\"btn\"&gt;回到顶部↑&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function () { // 1.找到页面中的按钮 var totop = document.getElementById(\"btn\"); totop.style.display =\"none\"; var timer = null; // 2. 给按钮绑定点击事件 totop.onclick =function () { // 周期性定时 timer = setInterval(function () { // 3.获取滚动条距离浏览器顶端的距离 var backTop = document.documentElement.scrollTop || document.body.scrollTop; // 越滚越慢 speedTop =backTop/5; document.documentElement.scrollTop=backTop-speedTop; if(backTop==0){ clearInterval(timer); } },30) } // 设置临界值 var pageHeight =700; window.onscroll =function () { var backTop = document.documentElement.scrollTop || document.body.scrollTop; if(backTop&gt;pageHeight){ totop.style.display=\"block\"; }else{ totop.style.display=\"none\"; } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后有一段是js设计动画的代码，原本应该直接引用写好的js文件，无奈总是引用出错，只好贴进正文里了QwQ。。。","categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://silence-tang.github.io/tags/HTML/"},{"name":"GitHub","slug":"GitHub","permalink":"http://silence-tang.github.io/tags/GitHub/"}]},{"title":"Python简易贪吃蛇小游戏（双人模式）","slug":"Python简易贪吃蛇小游戏（双人模式）","date":"2021-09-06T12:11:00.000Z","updated":"2021-09-06T12:15:09.935Z","comments":true,"path":"2021/09/06/Python简易贪吃蛇小游戏（双人模式）/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E7%AE%80%E6%98%93%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F%EF%BC%88%E5%8F%8C%E4%BA%BA%E6%A8%A1%E5%BC%8F%EF%BC%89/","excerpt":"这里介绍双人模式的贪吃蛇 单人模式戳这里：Python简易贪吃蛇小游戏（单人模式） 一、游戏设计要点 1.游戏主体窗口（尺寸）、画布（尺寸、位置）、按钮（尺寸、位置）、文字（大小、颜色、位置）、图像、背景音乐及相关响应函数（主要是鼠标移动及点击的响应）的设计与合理排布 2.蛇与食物的类的属性设计 3.蛇位置的更新（根据键盘输入）、吃到食物加分的判定、食物的更新 4.蛇死亡的判定条件设计","text":"这里介绍双人模式的贪吃蛇 单人模式戳这里：Python简易贪吃蛇小游戏（单人模式） 一、游戏设计要点 1.游戏主体窗口（尺寸）、画布（尺寸、位置）、按钮（尺寸、位置）、文字（大小、颜色、位置）、图像、背景音乐及相关响应函数（主要是鼠标移动及点击的响应）的设计与合理排布 2.蛇与食物的类的属性设计 3.蛇位置的更新（根据键盘输入）、吃到食物加分的判定、食物的更新 4.蛇死亡的判定条件设计 二、主要模块 1.pygame 2.sys 3.random 三、用到的类 1.Snake类，定义蛇头蛇身元素的位置 2.Food类，定义食物元素的位置及单个元素的颜色 四、主要函数1.new_food()，功能：生成一个不与蛇头位置重合的食物并返回该食物对象 12345678910def new_food(head): while True: # 循环，不断实例化new_food对象直到生成一个不与蛇头重合的食物 new_food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) # 若new_food和蛇头重合则不创键 if new_food.x != head.x and new_food.y != head.y: break else: continue return new_food 2.draw_snake()、draw_food()函数，功能：绘制蛇与食物的图像，传入参数为颜色和对象： 123456789# 在窗体中绘制贪吃蛇# 形参：一个是颜色另一个是实例化对象def draw_snake(color, object): pygame.draw.circle(window, color, (object.x, object.y), 10) # 在窗体中绘制食物# 形参：实例化对象def draw_food(food): pygame.draw.circle(window, food.color, (food.x, food.y), 10) 3.show_end函数，功能：显示双人模式结束时的得分界面： 12345678910111213141516def show_end(): while True: window.blit(init_background, (0, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: exit_end() # 定义标题 pygame.display.set_caption(\"贪吃蛇大冒险\") # 定义提示文字 font = pygame.font.SysFont(\"simHei\", 40) fontsurf = font.render('游戏结束! 玩家1得分: %s 玩家2得分：%s' % (score1, score2), True, black) window.blit(fontsurf, (150, 100)) button(\"返回主菜单\", 370, 300, 200, 40, blue, brightred, into_game) button(\"退出游戏\", 370, 470, 200, 40, red, brightred, exit_end) pygame.display.update() clock.tick(20) 4.exit_end()函数，功能：在初始界面和游戏结束显示得分界面点击右上角的”×”时，直接退出整个游戏： 1234# 初始界面和游戏中途点击退出游戏时def exit_end(): pygame.quit() sys.exit() 5.start_game_double()函数，功能：实现双人正常模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193def start_game_double(): # 播放音乐 pygame.mixer.music.play(-1) # 定义存分数的全局变量 global score1 global score2 score1 = score2 = 0 # 初始化存放玩家键盘输入运动方向的变量 run_direction1 = \"right\" run_direction2 = \"up\" # 初始化贪吃蛇运动方向的变量 run1 = run_direction1 run2 = run_direction2 # 实例化贪吃蛇和食物对象 head1 = Snake(randint(0, 30) * 20, randint(0, 20) * 20) head2 = Snake(randint(0, 30) * 20, randint(0, 20) * 20) # 实例化蛇身长度为2个单位 snake_body1 = [Snake(head1.x, head1.y + 20), Snake(head1.x, head1.y + 40)] snake_body2 = [Snake(head2.x, head2.y + 20), Snake(head2.x, head2.y + 40)] # 实例化食物列表，列表随着其中食物被吃掉应该不断缩短 food_list = [Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))] for i in range(1,24): food_list.append(Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))) # 实例化单个食物，方便循环内生成单个新食物 food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) while True: window.blit(background, (0,0)) # 监听玩家键盘输入的运动方向值，并根据输入转为up、down、right或left，方便程序中调用 # pygame.event.get()返回一个列表，存放本次game执行中程序遇到的一连串事件（按时间顺序依次存放） for event in pygame.event.get(): # pygame.QUIT事件是指用户点击窗口右上角的\"×\" if event.type == pygame.QUIT: # 显示结果界面 show_end() # 若事件类型是按下键盘，分↑ ↓ ← →四种情况讨论 elif event.type == pygame.KEYDOWN: # 若事件类型是按下键盘↑ # key是键值，表示按下去的键值是什么 if event.key == pygame.K_UP: run_direction2 = \"up\" # 若事件类型是按下键盘↓ if event.key == pygame.K_DOWN: run_direction2 = \"down\" # 若事件类型是按下键盘← if event.key == pygame.K_LEFT: run_direction2 = \"left\" # 若事件类型是按下键盘→ if event.key == pygame.K_RIGHT: run_direction2 = \"right\" # 若事件类型是按下键盘↑ if event.key == ord('w'): run_direction1 = \"up\" # 若事件类型是按下键盘↓ if event.key == ord('s'): run_direction1 = \"down\" # 若事件类型是按下键盘← if event.key == ord('a'): run_direction1 = \"left\" # 若事件类型是按下键盘→ if event.key == ord('d'): run_direction1 = \"right\" # 绘制初始化的25个食物图像(24+1=25) # 随着该列表中的食物被吃掉，列表应该不断pop以清除已经被吃的事物 for item in food_list: draw_food(item) # 绘制被贪吃蛇吃掉后新增的食物图像 draw_food(food) # 绘制蛇头图像 # 在绘制蛇头之前先检查是不是已经死亡，如果已死亡，则不绘制 # ！！不能通过die_flag判断是否死亡因为每次循环一开头die_flag都初始化为False # 因此最好的方法是通过snake_body是否为空判断 if len(snake_body1) != 0: draw_snake(black, head1) if len(snake_body2) != 0: draw_snake(black, head2) # 绘制蛇身图像 for item in snake_body1: draw_snake(blue, item) for item in snake_body2: draw_snake(green, item) # 若蛇未死亡，则插入蛇头位置到蛇身列表中 # 即：若蛇已死亡，则保持snake_body为空不变 if len(snake_body1) != 0: snake_body1.insert(0, Snake(head1.x, head1.y)) if len(snake_body2) != 0: snake_body2.insert(0, Snake(head2.x, head2.y)) # 判断贪吃蛇原运动方向(run)与玩家键盘输入的运动方向(run_direction)是否违反正常运动情况 if run1 == \"up\" and not run_direction1 == \"down\": run1 = run_direction1 if run1 == \"down\" and not run_direction1 == \"up\": run1 = run_direction1 if run1 == \"left\" and not run_direction1 == \"right\": run1 = run_direction1 if run1 == \"right\" and not run_direction1 == \"left\": run1 = run_direction1 if run2 == \"up\" and not run_direction2 == \"down\": run2 = run_direction2 if run2 == \"down\" and not run_direction2 == \"up\": run2 = run_direction2 if run2 == \"left\" and not run_direction2 == \"right\": run2 = run_direction2 if run2 == \"right\" and not run_direction2 == \"left\": run2 = run_direction2 # 根据玩家键入方向进行蛇头坐标的更新 if run1 == \"up\": head1.y -= 20 if run1 == \"down\": head1.y += 20 if run1 == \"left\": head1.x -= 20 if run1 == \"right\": head1.x += 20 if run2 == \"up\": head2.y -= 20 if run2 == \"down\": head2.y += 20 if run2 == \"left\": head2.x -= 20 if run2 == \"right\": head2.x += 20 # 判断两条蛇是否死亡 # 初始化四个死亡标志为False die_flag1 = die_flag2 = False # 此时snake_body1,2中均已包含蛇头 # snake_body1,2第一个元素是蛇头，故不能从0号元素开始比较 # 因为该蛇蛇头必然和自己重合 # 这里snake_body1,2均从1号元素开始 # 所以snake_body1[1:]+snake_body2[1:]是纯粹存储蛇身的列表 for body in snake_body1[1:]+snake_body2[1:]: if head1.x == body.x and head1.y == body.y: die_flag1 = True if head2.x == body.x and head2.y == body.y: die_flag2 = True if die_flag1 == True or head1.x &lt; 0 or head1.x &gt; 960 or head1.y &lt; 0 or head1.y &gt; 600: # 注意：这边虽然蛇身列表清空，但head1对象仍存在 # 故必须要在上面的绘制蛇头代码前面加上if先判断蛇是否死亡 snake_body1.clear() if die_flag2 == True or head2.x &lt; 0 or head2.x &gt; 960 or head2.y &lt; 0 or head2.y &gt; 600: die_flag2 = True # 注意：这边虽然蛇身列表清空，但head1对象仍存在 # 故必须要在上面的绘制蛇头代码前面加上if先判断蛇是否死亡 snake_body2.clear() # 若两条蛇都死亡 # 同样地，只能通过snake_body是否为空判断蛇是否死亡 if len(snake_body1) == 0 and len(snake_body2) == 0: show_end() # 判断蛇头和食物坐标，若相等，则加分，并生成新的食物 # 定义标志，表明是否找到和蛇头相等的食物 global flag1 global flag2 flag1 = flag2 = 0 # 如果蛇头和食物重合 for item in food_list: # 在蛇1没死且蛇头1和某一食物坐标相等的条件下 if len(snake_body1) != 0 and (head1.x == item.x and head1.y == item.y or head1.x == food.x and head1.y == food.y): flag1 = 1 score1 += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head1) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break # 在蛇2没死的且蛇头2和某一食物坐标相等的条件下 elif len(snake_body2) != 0 and head2.x == item.x and head2.y == item.y or head2.x == food.x and head2.y == food.y: flag2 = 1 score2 += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head2) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break # 蛇1必须没死，否则pop会引发异常 if len(snake_body1) != 0 and flag1 == 0: snake_body1.pop() # 蛇2必须没死，否则pop会引发异常 if len(snake_body2) != 0 and flag2 == 0: snake_body2.pop () font = pygame.font.SysFont(\"simHei\", 25) mode_title1 = mode_title2 = font.render('正常模式', False, grey) socre_title1 = font.render('得分: %s' % score1, False, grey) socre_title2 = font.render('得分: %s' % score2, False, grey) window.blit(mode_title1, (50, 30)) window.blit(socre_title1, (50, 65)) window.blit(mode_title2, (800, 30)) window.blit(socre_title2, (800, 65)) # 更新蛇头蛇身和食物的数据 pygame.display.update() # 通过帧率设置贪吃蛇速度 clock.tick(8) 6.start_kgame_double()函数，功能：实现双人穿墙模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196def start_kgame_double(): # 播放音乐 pygame.mixer.music.play(-1) # 定义存分数的全局变量 global score1 global score2 score1 = score2 = 0 # 初始化存放玩家键盘输入运动方向的变量 run_direction1 = \"right\" run_direction2 = \"up\" # 初始化贪吃蛇运动方向的变量 run1 = run_direction1 run2 = run_direction2 # 实例化贪吃蛇和食物对象 head1 = Snake(randint(0, 30) * 20, randint(0, 20) * 20) head2 = Snake(randint(0, 30) * 20, randint(0, 20) * 20) # 实例化蛇身长度为2个单位 snake_body1 = [Snake(head1.x, head1.y + 20), Snake(head1.x, head1.y + 40)] snake_body2 = [Snake(head2.x, head2.y + 20), Snake(head2.x, head2.y + 40)] # 实例化食物列表，列表随着其中食物被吃掉应该不断缩短 food_list = [Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))] for i in range(1,24): food_list.append(Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))) # 实例化单个食物，方便循环内生成单个新食物 food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) while True: window.blit(background, (0,0)) # 监听玩家键盘输入的运动方向值，并根据输入转为up、down、right或left，方便程序中调用 # pygame.event.get()返回一个列表，存放本次game执行中程序遇到的一连串事件（按时间顺序依次存放） for event in pygame.event.get(): # pygame.QUIT事件是指用户点击窗口右上角的\"×\" if event.type == pygame.QUIT: # 显示结果界面 show_end() # 若事件类型是按下键盘，分↑ ↓ ← →四种情况讨论 elif event.type == pygame.KEYDOWN: # 若事件类型是按下键盘↑ # key是键值，表示按下去的键值是什么 if event.key == pygame.K_UP: run_direction2 = \"up\" # 若事件类型是按下键盘↓ if event.key == pygame.K_DOWN: run_direction2 = \"down\" # 若事件类型是按下键盘← if event.key == pygame.K_LEFT: run_direction2 = \"left\" # 若事件类型是按下键盘→ if event.key == pygame.K_RIGHT: run_direction2 = \"right\" # 若事件类型是按下键盘↑ if event.key == ord('w'): run_direction1 = \"up\" # 若事件类型是按下键盘↓ if event.key == ord('s'): run_direction1 = \"down\" # 若事件类型是按下键盘← if event.key == ord('a'): run_direction1 = \"left\" # 若事件类型是按下键盘→ if event.key == ord('d'): run_direction1 = \"right\" # 绘制初始化的25个食物图像(24+1=25) # 随着该列表中的食物被吃掉，列表应该不断pop以清除已经被吃的事物 for item in food_list: draw_food(item) # 绘制被贪吃蛇吃掉后新增的食物图像 draw_food(food) # 绘制蛇头图像 # 在绘制蛇头之前先检查是不是已经死亡，如果已死亡，则不绘制 if len(snake_body1) != 0: draw_snake(black, head1) if len(snake_body2) != 0: draw_snake(black, head2) # 绘制蛇身图像 for item in snake_body1: draw_snake(blue, item) for item in snake_body2: draw_snake(green, item) # 插入蛇头位置到蛇身列表中 if len(snake_body1) != 0: snake_body1.insert(0, Snake(head1.x, head1.y)) if len(snake_body2) != 0: snake_body2.insert(0, Snake(head2.x, head2.y)) # 判断贪吃蛇原运动方向(run)与玩家键盘输入的运动方向(run_direction)是否违反正常运动情况 if run1 == \"up\" and not run_direction1 == \"down\": run1 = run_direction1 if run1 == \"down\" and not run_direction1 == \"up\": run1 = run_direction1 if run1 == \"left\" and not run_direction1 == \"right\": run1 = run_direction1 if run1 == \"right\" and not run_direction1 == \"left\": run1 = run_direction1 if run2 == \"up\" and not run_direction2 == \"down\": run2 = run_direction2 if run2 == \"down\" and not run_direction2 == \"up\": run2 = run_direction2 if run2 == \"left\" and not run_direction2 == \"right\": run2 = run_direction2 if run2 == \"right\" and not run_direction2 == \"left\": run2 = run_direction2 # 根据玩家键入方向进行蛇头坐标的更新 if run1 == \"up\": head1.y -= 20 if run1 == \"down\": head1.y += 20 if run1 == \"left\": head1.x -= 20 if run1 == \"right\": head1.x += 20 if run2 == \"up\": head2.y -= 20 if run2 == \"down\": head2.y += 20 if run2 == \"left\": head2.x -= 20 if run2 == \"right\": head2.x += 20 # 实现穿墙 # 蛇头穿出窗体共有8种情况 if head1.x &lt; 0: head1.x = 960 if head1.x &gt; 960: head1.x = 0 if head1.y &lt; 0: head1.y = 600 if head1.y &gt; 600: head1.y = 0 if head2.x &lt; 0: head2.x = 960 if head2.x &gt; 960: head2.x = 0 if head2.y &lt; 0: head2.y = 600 if head2.y &gt; 600: head2.y = 0 # 定义死亡标志位 die_flag1 = die_flag2 = False for body in snake_body1[1:]+snake_body2[1:]: if head1.x == body.x and head1.y == body.y: die_flag1 = True if head2.x == body.x and head2.y == body.y: die_flag2 = True if die_flag1 == True: snake_body1.clear() if die_flag2 == True: snake_body2.clear() # 若两条蛇都死亡 if len(snake_body1) == 0 and len(snake_body2) == 0: show_end() # 判断蛇头和食物坐标，若相等，则加分，并生成新的食物 # 定义标志，表明是否找到和蛇头相等的食物 global flag1 global flag2 flag1 = flag2 = 0 # 如果蛇头和食物重合 for item in food_list: # 在蛇1没死且蛇头1和某一食物坐标相等的条件下 if len(snake_body1) != 0 and (head1.x == item.x and head1.y == item.y or head1.x == food.x and head1.y == food.y): flag1 = 1 score1 += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head1) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break # 在蛇2没死的且蛇头2和某一食物坐标相等的条件下 elif len(snake_body2) != 0 and head2.x == item.x and head2.y == item.y or head2.x == food.x and head2.y == food.y: flag2 = 1 score2 += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head2) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break # 蛇1必须没死，否则pop会引发异常 if len(snake_body1) != 0 and flag1 == 0: snake_body1.pop() # 蛇2必须没死，否则pop会引发异常 if len(snake_body2) != 0 and flag2 == 0: snake_body2.pop () font = pygame.font.SysFont(\"simHei\", 25) mode_title1 = mode_title2 = font.render('穿墙模式', False, grey) socre_title1 = font.render('得分: %s' % score1, False, grey) socre_title2 = font.render('得分: %s' % score2, False, grey) window.blit(mode_title1, (50, 30)) window.blit(socre_title1, (50, 65)) window.blit(mode_title2, (800, 30)) window.blit(socre_title2, (800, 65)) # 更新蛇头蛇身和食物的数据 pygame.display.update() # 通过帧率设置贪吃蛇速度 clock.tick(8) 7.button()函数，功能：实现按钮样式设计和响应鼠标操作： 1234567891011121314151617def button(msg, x, y, w, h, ic, ac, action=None): # 获取鼠标位置 mouse = pygame.mouse.get_pos() # 获取鼠标点击情况 click = pygame.mouse.get_pressed() if x + w &gt; mouse[0] &gt; x and y + h &gt; mouse[1] &gt; y: pygame.draw.rect(window, ac, (x, y, w, h)) if click[0] == 1 and action != None: action() else: pygame.draw.rect(window, ic, (x, y, w, h)) # 设置按钮中的文字样式和居中对齐 font = pygame.font.SysFont('simHei', 20) smallfont = font.render(msg, True, white) smallrect = smallfont.get_rect() smallrect.center = ((x + (w / 2)), (y + (h / 2))) window.blit(smallfont, smallrect) 8.into_game()函数，功能：实现游戏初始界面，选择模式： 123456789101112131415161718def into_game(): while True: window.blit(init_background, (0, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: exit_end() # 设置字体 font = pygame.font.SysFont(\"simHei\", 50) # 初始界面显示文字 fontsurf = font.render('欢迎来到贪吃蛇大冒险!', True, black) # 文字 fontrect = fontsurf.get_rect() fontrect.center = ((480), 200) window.blit(fontsurf, fontrect) button(\"正常模式\", 370, 370, 200, 40, blue, brightred, start_game_double) button(\"可穿墙模式\", 370, 420, 200, 40, violte, brightred, start_kgame_double) button(\"退出游戏\", 370, 470, 200, 40, red, brightred, exit_end) pygame.display.update() clock.tick(20) 9.主函数，功能：初始化参数设定，进入游戏： 123456789101112131415161718192021222324252627if __name__ == '__main__': # 定义需要用到的颜色 white = (255, 255, 255) red = (200, 0, 0) green = (0, 128, 0) blue = (0, 202, 254) violte = (194, 8, 234) brightred = (255, 0, 0) brightgreen = (0, 255, 0) black = (0, 0, 0) grey = (129, 131, 129) # 设计窗口 window = pygame.display.set_mode((960, 600)) # 定义标题 pygame.display.set_caption(\"贪吃蛇大冒险\") # 定义背景图片 init_background = pygame.image.load(\"image/init_bgimg.jpg\") background = pygame.image.load(\"image/bgimg.jpg\") # 背景音乐 pygame.mixer.init() pygame.mixer.music.load(\"background.mp3\") # 创建时钟 clock = pygame.time.Clock() # 初始化，自检所有模块是否完整 pygame.init() # 初始界面 into_game() 注：其中的图片、背景音乐需要自己找合适（尺寸要与窗口大小相适应）的，也可以参考我上传的资源贪吃蛇双人版源码+图片+音乐。 附：贪吃蛇 单人+双人整合版源码","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"pygame","slug":"pygame","permalink":"http://silence-tang.github.io/tags/pygame/"}]},{"title":"Python爬虫学习-简单爬取网页数据","slug":"Python爬虫学习-简单爬取网页数据","date":"2021-09-06T12:04:00.000Z","updated":"2021-09-06T12:06:03.672Z","comments":true,"path":"2021/09/06/Python爬虫学习-简单爬取网页数据/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE/","excerpt":"疫情宅家无事，就随便写一些随笔吧QwQ… 这是一篇介绍如何用Python实现简单爬取网页数据并导入MySQL中的数据库的文章。主要用到BeautifulSoup requests 和 pymysql。 以网页https://jbk.39.net/mxyy/jbzs/为例，假设我们要爬取的部分数据如下图所示：","text":"疫情宅家无事，就随便写一些随笔吧QwQ… 这是一篇介绍如何用Python实现简单爬取网页数据并导入MySQL中的数据库的文章。主要用到BeautifulSoup requests 和 pymysql。 以网页https://jbk.39.net/mxyy/jbzs/为例，假设我们要爬取的部分数据如下图所示： 一、准备工作 1.导入BeautifulSoup和requests库： 12from bs4 import BeautifulSoupimport requests 2.要想获得网页html内容，我们首先需要用requests库的.get()方法向该网页的服务器构造并发送一个请求。requests.get()方法需要传递两个参数，一个是网页的url，在这里显然是https://jbk.39.net/mxyy/jbzs/；另一个参数是浏览器的header。查看方法如下： 点击进入任意一个网页页面，按F12进入开发者模式，点击Network再刷新网页。在Network下的Name中任意点击一个资源，在右侧的Headers版块中下拉到最后，可以看见Request Headers参数列表最后有一个user-agent，其内容就是我们要找的浏览器headers参数值。 有了url和headers我们就可以利用requests.get()向服务器发送请求了： 123headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36'}url = \"https://jbk.39.net/mxyy/jbzs/\"r = requests.get(url, headers = headers) 使用requests.get()方法会先构造一个向服务器请求资源的url对象然后从服务器返回一个包含服务器资源的Response对象，其中包含从服务器返回的所有相关资源（自然也包括我们所需的html）。 获取网页的html内容： 1html = r.content.decode('utf-8', 'ignore') 解释：这里r.content返回“Content of the response, in bytes.”即返回HTTP响应内容（Response）的字节形式。因此我们需要使用.decode()方法来解码。这里ignore参数可要可不要，仅仅是为了忽略一些不重要的错误。 有了html文本我们就可以把bs拿出来溜了： 1my_page = BeautifulSoup(html, 'lxml') 其实这里得到的my_page和html内容几乎一致，那么为什么还要用bs再次解析html呢？答：Beautiful Soup 是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(Parse Tree)。 它提供简单又常用的导航(Navigating)，搜索以及修改剖析树的操作，可以大大节省你的编程时间。也就是说，我们爬取数据需要用到的一些定位方法只有经由bs解析后返回的内容才能使用，单纯的html文本是不具备这样的方便快捷的方法的。 二、开始爬取数据 在这里我们用到的方法主要是find | find_all | findAll | get_text() | text。 1.find_all方法： 功能是查找该页面元素的所有子元素并且将寻找到的符合查找结果的子元素以列表的形式返回。 2.find方法： 与find_all差不多，但是只返回第一个与查找条件匹配的子元素，且仅返回文本，不以列表形式返回。 3.get_text()和.text方法： 用来提取标签中的文本信息。 ps:get_text()和.text方法的区别： beautifulsoup中，对外接口，没有提供text这个属性，只有string这个属性值；beautifulsoup内部才有text这个属性，只供内部使用 –&gt; 如果你想要用text值，应该调用对应的get_text()；而你之所有能够直接用soup.text而没报错，应该是和python的class的property没有变成private有关系 –&gt;导致你外部也可以访问到这个，本身是只供内部使用的属性值。 4.具体实现示例： 123456789101112for tag in my_page.find_all('div', class_='list_left'): sub_tag = tag.find('ul',class_=\"disease_basic\") my_span = sub_tag.findAll('span') #my_span可以认为是一个list is_yibao = my_span[1].text othername = my_span[3].text fbbw = my_span[5].text is_infect = my_span[7].text dfrq = my_span[9].text my_a = sub_tag.findAll('a') fbbw = my_a[0].text #注：也可用.contents[0]或者.get_text() 用以实现爬取“是否属于医保”等条目冒号后面的内容。 如何查找find_all()参数值？ 选中需要查找的内容并右键单击，选择“检查”，进入开发者模式，可看到相关内容的html代码如下图所示： 可见，我们想爬的内容首先在一个class属性为“list_left”的div标签内—&gt;在该div标签内又可发现想爬的内容在class属性为“disease_basic”的列表元素ul标签内—&gt;在ul标签内可以发现我们想要的内容就分别藏在几个span标签内。 三、完整代码12345678910111213141516171819202122232425262728293031323334353637# coding = utf-8from bs4 import BeautifulSoupimport requestsheaders = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36'}url = \"https://jbk.39.net/mxyy/jbzs/\"r = requests.get(url, headers = headers)html = r.content.decode('utf-8', 'ignore')my_page = BeautifulSoup(html, 'lxml')for tag in my_page.find_all('div', class_='disease'): disease = tag.find('h1').get_text() disease_name = diseasefor tag in my_page.find_all('p', class_='introduction'): introduction = tag.get_text() disease_introduction = introductionfor tag in my_page.find_all('div', class_='list_left'): sub_tag = tag.find('ul',class_=\"disease_basic\") my_span = sub_tag.findAll('span') #my_span is a list is_yibao = my_span[1].text #是否医保 othername = my_span[3].text #别名 fbbw = my_span[5].text #发病部位 is_infect = my_span[7].text #传染性 dfrq = my_span[9].text #多发人群 my_a = sub_tag.findAll('a') xgzz = my_a[2].text+' '+my_a[3].text+' '+my_a[4].text #相关症状 #ps: .contents[0] or .get_text() is also accepted# Some tests:# print(html)# print(my_page)# print(sub_tag)# print(xgzz)# print(my_span)# print(my_span[1])","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://silence-tang.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python简易贪吃蛇小游戏（单人模式）","slug":"Python简易贪吃蛇小游戏（单人模式）","date":"2021-09-06T12:04:00.000Z","updated":"2021-09-06T12:11:07.386Z","comments":true,"path":"2021/09/06/Python简易贪吃蛇小游戏（单人模式）/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E7%AE%80%E6%98%93%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F%EF%BC%88%E5%8D%95%E4%BA%BA%E6%A8%A1%E5%BC%8F%EF%BC%89/","excerpt":"简单用py写了一个贪吃蛇游戏，有单人、双人模式，比较简单，适合初学者练手。基本上每行重要的语句都有注释，做了什么事一目了然 这里先介绍单人模式 一、游戏设计要点 1.游戏主体窗口（尺寸）、画布（尺寸、位置）、按钮（尺寸、位置）、文字（大小、颜色、位置）、图像、背景音乐及相关响应函数（主要是鼠标移动及点击的响应）的设计与合理排布 2.蛇与食物的类的属性设计 3.蛇位置的更新（根据键盘输入）、吃到食物加分的判定、食物的更新 4.蛇死亡的判定条件设计","text":"简单用py写了一个贪吃蛇游戏，有单人、双人模式，比较简单，适合初学者练手。基本上每行重要的语句都有注释，做了什么事一目了然 这里先介绍单人模式 一、游戏设计要点 1.游戏主体窗口（尺寸）、画布（尺寸、位置）、按钮（尺寸、位置）、文字（大小、颜色、位置）、图像、背景音乐及相关响应函数（主要是鼠标移动及点击的响应）的设计与合理排布 2.蛇与食物的类的属性设计 3.蛇位置的更新（根据键盘输入）、吃到食物加分的判定、食物的更新 4.蛇死亡的判定条件设计 二、主要模块1.pygame2.sys3.random 三、用到的类1.Snake类，定义蛇头蛇身元素的位置2.Food类，定义食物元素的位置及单个元素的颜色 四、主要函数1.new_food()，功能：生成一个不与蛇头位置重合的食物并返回该食物对象 12345678910def new_food(head): while True: # 循环，不断实例化new_food对象直到生成一个不与蛇头重合的食物 new_food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) # 若new_food和蛇头重合则不创键 if new_food.x != head.x and new_food.y != head.y: break else: continue return new_food 2.draw_snake()、draw_food()函数，功能：绘制蛇与食物的图像，传入参数为颜色和对象： 123456789# 在窗体中绘制贪吃蛇# 形参：一个是颜色另一个是实例化对象def draw_snake(color, object): pygame.draw.circle(window, color, (object.x, object.y), 10) # 在窗体中绘制食物# 形参：实例化对象def draw_food(food): pygame.draw.circle(window, food.color, (food.x, food.y), 10) 3.show_end函数，功能：显示单人模式结束时的得分界面： 1234567891011121314151617# 游戏结束时，单人模式显示得分的窗体的设置def show_end_single(): while True: window.blit(init_background, (0, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: exit_end() # 定义标题 pygame.display.set_caption(\"贪吃蛇大冒险\") # 定义提示文字 font = pygame.font.SysFont(\"simHei\", 40) fontsurf = font.render('游戏结束! 你的得分为: %s' % score, False, black) window.blit(fontsurf, (250, 100)) button(\"返回主菜单\", 370, 300, 200, 40, blue, brightred, into_game) button(\"退出游戏\", 370, 470, 200, 40, red, brightred, exit_end) pygame.display.update() clock.tick(20) 4.exit_end()函数，功能：在初始界面和游戏结束显示得分界面点击右上角的”×”时，直接退出整个游戏： 123def exit_end(): pygame.quit() sys.exit() 5.start_game()函数，功能：实现单人正常模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115def start_game(): # 播放音乐 pygame.mixer.music.play(-1) # 定义存分数的全局变量 global score score = 0 # 定义存放玩家键盘输入运动方向的变量，初始为向右 run_direction = \"right\" # 定义贪吃蛇运动方向的变量，初始为玩家键入方向 run = run_direction # 实例化贪吃蛇和食物对象 head = Snake(randint(0, 30) * 20, randint(0, 20) * 20) # 实例化蛇身长度为2个单位 snake_body = [Snake(head.x, head.y + 20), Snake(head.x, head.y + 40)] # 实例化食物列表，列表随着其中食物被吃掉应该不断缩短 food_list = [Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))] for i in range(1,24): food_list.append(Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))) # 实例化单个食物，方便循环内生成单个新食物 food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) while True: window.blit(background, (0,0)) # 监听玩家键盘输入的运动方向值，并根据输入转为up、down、right或left，方便程序中调用 # pygame.event.get()返回一个列表，存放本次game执行中程序遇到的一连串事件（按时间顺序依次存放） for event in pygame.event.get(): # pygame.QUIT事件是指用户点击窗口右上角的\"×\" if event.type == pygame.QUIT: # 显示结果界面 show_end() # 若事件类型是按下键盘，分↑ ↓ ← →四种情况讨论 elif event.type == pygame.KEYDOWN: # 若事件类型是按下键盘↑ # key是键值，表示按下去的键值是什么 if event.key == ord('w'): run_direction = \"up\" # 若事件类型是按下键盘↓ if event.key == ord('s'): run_direction = \"down\" # 若事件类型是按下键盘← if event.key == ord('a'): run_direction = \"left\" # 若事件类型是按下键盘→ if event.key == ord('d'): run_direction = \"right\" # 绘制初始化的25个食物图像(24+1=25) # 随着该列表中的食物被吃掉，列表应该不断pop以清除已经被吃的事物 for item in food_list: draw_food(item) # 绘制被贪吃蛇吃掉后新增的食物图像 draw_food(food) # 绘制蛇头图像 draw_snake(black, head) # 绘制蛇身图像 for item in snake_body: draw_snake(blue, item) # 判断贪吃蛇原运动方向(run)与玩家键盘输入的运动方向(run_direction)是否违反正常运动情况 if run == \"up\" and not run_direction == \"down\": run = run_direction elif run == \"down\" and not run_direction == \"up\": run = run_direction elif run == \"left\" and not run_direction == \"right\": run = run_direction elif run == \"right\" and not run_direction == \"left\": run = run_direction # 插入蛇头位置到蛇身列表中 snake_body.insert(0, Snake(head.x, head.y)) # 根据玩家键入方向进行蛇头xy的更新 if run == \"up\": head.y -= 20 elif run == \"down\": head.y += 20 elif run == \"left\": head.x -= 20 elif run == \"right\": head.x += 20 # 判断是否死亡 die_flag = False # 遍历存放贪吃蛇位姿的列表，从第1个开始，(第0个位蛇头) for body in snake_body[1:]: # 如果蛇头的xy和蛇身xy相等，则判定相撞，设置flag为ture if head.x == body.x and head.y == body.y: die_flag = True # 若蛇头的xy在显示窗体外，或flag为true，则显示结束界面，并退出游戏 if die_flag == True or head.x &lt; 0 or head.x &gt; 960 or head.y &lt; 0 or head.y &gt; 600: # 停止播放音乐 pygame.mixer.music.stop() show_end() # die_snake(head, snake_body) # 判断蛇头和食物坐标，若相等，则加分，并生成新的食物 # 定义标志，表明是否找到和蛇头相等的事物 global flag flag = 0 # 如果蛇头和食物重合 for item in food_list: if head.x == item.x and head.y == item.y or head.x == food.x and head.y == food.y: flag = 1 score += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break if flag == 0: snake_body.pop() font = pygame.font.SysFont(\"simHei\", 25) mode_title = font.render('正常模式', False, grey) socre_title = font.render('得分: %s' % score, False, grey) window.blit(mode_title, (50, 30)) window.blit(socre_title, (50, 65)) # 更新蛇头蛇身和食物的数据 pygame.display.update() # 通过帧率设置贪吃蛇速度 clock.tick(8) 6.start_kgame()函数，功能：实现单人穿墙模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118def start_kgame_single(): # 播放音乐 pygame.mixer.music.play(-1) global score score = 0 # 定义存放玩家键盘输入运动方向的变量，初始为向右 run_direction = \"right\" # 定义贪吃蛇运动方向的变量，初始为玩家键入方向 run = run_direction # 实例化蛇头、蛇身、食物对象 head = Snake(160, 160) # 实例化蛇身 snake_body = [Snake(head.x, head.y + 20), Snake(head.x, head.y + 40), Snake(head.x, head.y + 60)] # 实例化食物列表，列表随着其中食物被吃掉应该不断缩短 food_list = [Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))] for i in range(1,24): food_list.append(Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255)))) # 实例化单个食物，方便循环内生成单个新食物 food = Food(randint(0, 45) * 20, randint(0, 28) * 20, (randint(10, 255), randint(10, 255), randint(10, 255))) # 死循环，监听键盘键值 while True: window.blit(background, (0, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: show_end_single() elif event.type == pygame.KEYDOWN: # 若事件类型是按下键盘w # key是键值，表示按下去的键值是什么 if event.key == ord('w'): run_direction = \"up\" # 若事件类型是按下键盘s if event.key == ord('s'): run_direction = \"down\" # 若事件类型是按下键盘a if event.key == ord('a'): run_direction = \"left\" # 若事件类型是按下键盘d if event.key == ord('d'): run_direction = \"right\" # 绘制初始化的25个食物图像(24+1=25) # 随着该列表中的食物被吃掉，列表应该不断pop以清除已经被吃的事物 for item in food_list: draw_food(item) # 绘制被贪吃蛇吃掉后新增的食物图像 draw_food(food) # 绘制蛇头图像 draw_snake(black, head) # 绘制蛇身图像 for item in snake_body: draw_snake(blue, item) # 判断贪吃蛇原运动方向与玩家键盘输入的运动方向是否违反正常运动情况 if run == \"up\" and not run_direction == \"down\": # 若运动方向为向上，玩家输入运动方向向下，则违背贪吃蛇正常运动情况 run = run_direction elif run == \"down\" and not run_direction == \"up\": run = run_direction elif run == \"left\" and not run_direction == \"right\": run = run_direction elif run == \"right\" and not run_direction == \"left\": run = run_direction # 插入蛇头位置到蛇身列表中 snake_body.insert(0, Snake(head.x, head.y)) # 根据玩家键入方向进行蛇头xy的更新 if run == \"up\": head.y -= 20 elif run == \"down\": head.y += 20 elif run == \"left\": head.x -= 20 elif run == \"right\": head.x += 20 # 穿墙实现 # 定义标志位 die_flag = False # 遍历，蛇头碰到蛇身时，flag为true退出游戏 for body in snake_body[1:]: if head.x == body.x and head.y == body.y: die_flag = True if die_flag: pygame.mixer.music.stop() show_end() else: # 当蛇头穿出窗体时有四种情况，分别讨论 if head.x &lt; 0: head.x = 960 if head.x &gt; 960: head.x = 0 if head.y &lt; 0: head.y = 600 if head.y &gt; 600: head.y = 0 # 判断蛇头和食物坐标，若相等，则加分，并生成新的食物 # 定义标志，表明是否找到和蛇头相等的事物 global flag flag = 0 # 如果蛇头和食物重合 for item in food_list: if head.x == item.x and head.y == item.y or head.x == food.x and head.y == food.y: flag = 1 score += 1 # 弹出被吃掉的这个食物 food_list.pop(food_list.index(item)) # 再产生一个食物 food = new_food(head) # 把新食物插入food_list，下一次循环中会更新绘制食物全体 food_list.append(food) break # 若没吃到食物则从蛇身pop一个元素以更新蛇位置 if flag == 0: snake_body.pop() font = pygame.font.SysFont(\"simHei\", 25) mode_title = font.render('穿墙模式', False, grey) socre_title = font.render('得分: %s' % score, False, grey) window.blit(mode_title, (50, 30)) window.blit(socre_title, (50, 65)) # 绘制更新 pygame.display.update() # 通过帧率设置贪吃蛇速度 clock.tick(8) 7.button()函数，功能：实现按钮样式设计和响应鼠标操作： 1234567891011121314151617def button(msg, x, y, w, h, ic, ac, action=None): # 获取鼠标位置 mouse = pygame.mouse.get_pos() # 获取鼠标点击情况 click = pygame.mouse.get_pressed() if x + w &gt; mouse[0] &gt; x and y + h &gt; mouse[1] &gt; y: pygame.draw.rect(window, ac, (x, y, w, h)) if click[0] == 1 and action != None: action() else: pygame.draw.rect(window, ic, (x, y, w, h)) # 设置按钮中的文字样式和居中对齐 font = pygame.font.SysFont('simHei', 20) smallfont = font.render(msg, True, white) smallrect = smallfont.get_rect() smallrect.center = ((x + (w / 2)), (y + (h / 2))) window.blit(smallfont, smallrect) 8.into_game()函数，功能：实现游戏初始界面，选择模式： 123456789101112131415161718def into_game(): while True: window.blit(init_background, (0, 0)) for event in pygame.event.get(): if event.type == pygame.QUIT: exit_end() # 设置字体 font = pygame.font.SysFont(\"simHei\", 50) # 初始界面显示文字 fontsurf = font.render('欢迎来到贪吃蛇大冒险!', True, black) # 文字 fontrect = fontsurf.get_rect() fontrect.center = ((480), 200) window.blit(fontsurf, fontrect) button(\"正常模式\", 370, 370, 200, 40, blue, brightred, start_game) button(\"可穿墙模式\", 370, 420, 200, 40, violte, brightred, start_kgame) button(\"退出游戏\", 370, 470, 200, 40, red, brightred, exit_end) pygame.display.update() clock.tick(20) 9.主函数，功能：初始化参数设定，进入游戏： 123456789101112131415161718192021222324252627if __name__ == '__main__': # 定义需要用到的颜色 white = (255, 255, 255) red = (200, 0, 0) green = (0, 128, 0) blue = (0, 202, 254) violte = (194, 8, 234) brightred = (255, 0, 0) brightgreen = (0, 255, 0) black = (0, 0, 0) grey = (129, 131, 129) # 设计窗口 window = pygame.display.set_mode((960, 600)) # 定义标题 pygame.display.set_caption(\"贪吃蛇大冒险\") # 定义背景图片 init_background = pygame.image.load(\"image/init_bgimg.jpg\") background = pygame.image.load(\"image/bgimg.jpg\") # 背景音乐 pygame.mixer.init() pygame.mixer.music.load(\"background.mp3\") # 创建时钟 clock = pygame.time.Clock() # 初始化，自检所有模块是否完整 pygame.init() # 初始界面 into_game() 注：其中的图片、背景音乐需要自己找合适（尺寸要与窗口大小相适应）的，也可以参考我上传的资源：贪吃蛇单人版源代码+背景+音乐 附：Blog:双人模式详解","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"pygame","slug":"pygame","permalink":"http://silence-tang.github.io/tags/pygame/"}]},{"title":"Python操作MySQL数据库实现数据导入","slug":"Python操作MySQL数据库实现数据导入","date":"2021-09-06T12:00:00.000Z","updated":"2021-09-06T12:04:15.178Z","comments":true,"path":"2021/09/06/Python操作MySQL数据库实现数据导入/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/","excerpt":"主要参考了博文python3基础：操作mysql数据库 这篇文章写的很详细，基本上把用Python操作MySQL的各种操作都详细解释了，也有配图。 注：在使用Python进行操作之前，首先需要在本地的MySQL Command Line Client命令行客户端中实现用户注册、登录、创建数据库、数据表、定义表中的各条目属性等操作，这些操作不在本文中叙述。 一、操作流程 引用API模块 获取与数据库的连接 执行sql语句与存储过程 关闭数据库连接","text":"主要参考了博文python3基础：操作mysql数据库 这篇文章写的很详细，基本上把用Python操作MySQL的各种操作都详细解释了，也有配图。 注：在使用Python进行操作之前，首先需要在本地的MySQL Command Line Client命令行客户端中实现用户注册、登录、创建数据库、数据表、定义表中的各条目属性等操作，这些操作不在本文中叙述。 一、操作流程 引用API模块 获取与数据库的连接 执行sql语句与存储过程 关闭数据库连接 二、具体操作1.安装pymysql python3 与MySQL 进行交互编程需要安装 pymysql 库，故首先在命令行中使用如下命令安装pymysql：pip install pymysql2.连接数据库 12345import pymysql#打开数据库连接conn = pymysql.connect('localhost',user = \"root\",passwd = \"******\",db = \"testdb\")print (conn)print (type(conn)) 3.获取游标 要想操作数据库，光连接数据是不够的，必须拿到操作数据库的游标，才能进行后续的操作，比如读取数据、添加数据。通过获取到的数据库连接实例conn下的cursor()方法来创建游标。游标用来接收返回结果： 123456import pymysql#打开数据库连接conn = pymysql.connect('localhost',user = \"root\",passwd = \"123456\",db = \"testdb\")#获取游标cursor=conn.cursor()print(cursor) 说明：cursor返回一个游标实例对象，其中包含了很多操作数据的方法，比如执行sql语句。4.执行sql语句execute和executemany execute(query,args=None) 函数作用：执行单条的sql语句，执行成功后返回受影响的行数 参数说明：query：要执行的sql语句，字符串类型args：可选的序列或映射，用于query的参数值。如果args为序列，query中必须使用%s做占位符；如果args为映射，query中必须使用%(key)s做占位符 executemany(query,args=None) 函数作用：批量执行sql语句，比如批量插入数据，执行成功后返回受影响的行数 参数说明：query：要执行的sql语句，字符串类型args：嵌套的序列或映射，用于query的参数值 注意： 1.数据库性能瓶颈很大一部份就在于网络IO和磁盘IO，将多个sql语句放在一起，只执行一次IO，可以有效的提升数据库性能。推荐此方法 2.用executemany()方法一次性批量执行sql语句，固然很好，但是当数据一次传入过多到server端，可能造成server端的buffer溢出，也可能产生一些意想不到的麻烦。所以，合理、分批次使用executemany是个合理的办法。 三、完整代码","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://silence-tang.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Python selenium自动化刷问卷+绕过智能验证","slug":"Python selenium自动化刷问卷+绕过智能验证","date":"2021-09-06T11:58:00.000Z","updated":"2021-09-06T11:59:14.675Z","comments":true,"path":"2021/09/06/Python selenium自动化刷问卷+绕过智能验证/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%20selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%B7%E9%97%AE%E5%8D%B7+%E7%BB%95%E8%BF%87%E6%99%BA%E8%83%BD%E9%AA%8C%E8%AF%81/","excerpt":"学校思政实践要收集1500份问卷，待在家里无聊就简单写了个用selenium模块实现的自动填写问卷星问卷的小程序。 基本思路很简单： 1.先打开问卷的网址，按F12进开发者模式分析页面HTML，找到题目的选项按钮对应的HTML代码（例如：Q1的四个选项按钮都在a标签内，且rel属性值分别为q1_1,q1_2,q1_3,q1_4）； 2.在py中用slenium的find_element_by_xpath+click()方法实现模拟点击按钮，例如：","text":"学校思政实践要收集1500份问卷，待在家里无聊就简单写了个用selenium模块实现的自动填写问卷星问卷的小程序。 基本思路很简单： 1.先打开问卷的网址，按F12进开发者模式分析页面HTML，找到题目的选项按钮对应的HTML代码（例如：Q1的四个选项按钮都在a标签内，且rel属性值分别为q1_1,q1_2,q1_3,q1_4）； 2.在py中用slenium的find_element_by_xpath+click()方法实现模拟点击按钮，例如： 1234567q1 = random()if 0 &lt;= q1 &lt;= 0.5: # 通过属性定位元素 # q1_1是Q1的第1个按钮 driver.find_element_by_xpath(\"//a[@rel='q1_1']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q1_2']\").click() 3.若想模拟人的选择偏好，就用随机数区间+if语句控制，无非就是多写几条语句； 4.最后填写完问卷提交也是一样的，find_element找到提交按钮的html对应代码再click()。此时要注意——在py中用selenium模拟填写的问卷最后点击提交必定触发智能验证框： 这时你无论用人手点击或者是再模拟点击都是没法验证成功的。 这是因为问卷xing网页有反爬机制会检查你是不是通过selenium访问网页的。大多数情况下，检测基本原理是检测当前浏览器窗口下的window.navigator对象是否包含webdriver这个属性。因为在正常使用浏览器的情况下，这个属性是undefined，然而一旦我们使用了selenium，selenium会给window.navigator设置webdriver属性。很多网站就通过JS判断如果webdrive 属性存在，那就直接屏蔽。 网上搜了一下，基本看着都是用pyppeteer解决反爬的方法，安装python第三方库asyncio、pyppeteer和pyppeteer_stealth然后一顿操作猛如虎似乎可以绕过智能验证？这个方法我没试，大家可以试试看，附上相关博文：使用Python自动填写问卷星(pyppeteer反爬虫版)。 我参考了某位知乎答主的方法—— 通过 CDP 实现在每个页面刚加载的时候执行JS代码，执行的CDP方法叫作Page.addScriptToEvaluateOnNewDocument。传入一段JS代码: 12345678url = \"http://www.baidu.com\" #实例urloption = ChromeOptions()option.add_experimental_option('excludeSwitches', ['enable-automation'])option.add_experimental_option('useAutomationExtension', False)browser = webdriver.Chrome(options=option)browser.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {'source': 'Object.defineProperty(navigator, \"webdriver\", {get: () =&gt; undefined})'})browser.get(url) 这样就可以在每次页面加载之前将webdriver属性置空从而躲过智能检测。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205from selenium import webdriverimport timefrom random import *print(\"正在执行操作......\")# 给出所需的url和option参数url_survey = (\"https://www.wjx.cn/xx/xxxxxxx.aspx\") # 根据需要填写urloption = webdriver.ChromeOptions()option.add_experimental_option('excludeSwitches', ['enable-automation'])option.add_experimental_option('useAutomationExtension', False)driver = webdriver.Chrome(options=option)driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {'source': 'Object.defineProperty(navigator, \"webdriver\", {get: () =&gt; undefined})'})driver.get(url_survey)time.sleep(2)# 处理Q1# 生成随机数，决定点哪个按钮q1 = random()if 0 &lt;= q1 &lt;= 0.5: # 通过属性定位元素 # q1_1是Q1的第1个按钮 driver.find_element_by_xpath(\"//a[@rel='q1_1']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q1_2']\").click()# 处理Q2# 生成随机数，决定点哪个按钮q2 = random()if 0 &lt;= q2 &lt;= 0.25: driver.find_element_by_xpath(\"//a[@rel='q2_1']\").click()elif 0.25 &lt; q2 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q2_2']\").click()elif 0.50 &lt; q2 &lt;= 0.75: driver.find_element_by_xpath(\"//a[@rel='q2_3']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q2_4']\").click()# 处理Q3# 生成随机数，决定点哪个按钮q3 = random()if 0 &lt;= q3 &lt;= 0.25: driver.find_element_by_xpath(\"//a[@rel='q3_1']\").click()elif 0.25 &lt; q3 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q3_2']\").click()elif 0.50 &lt; q3 &lt;= 0.75: driver.find_element_by_xpath(\"//a[@rel='q3_3']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q3_4']\").click()# 处理Q4# 生成随机数，决定点哪个按钮q4 = random()driver.find_element_by_xpath(\"//a[@rel='q4_1']\").click()driver.find_element_by_xpath(\"//a[@rel='q4_2']\").click()driver.find_element_by_xpath(\"//a[@rel='q4_3']\").click()driver.find_element_by_xpath(\"//a[@rel='q4_5']\").click()driver.find_element_by_xpath(\"//a[@rel='q4_7']\").click()if 0 &lt;= q4 &lt;= 0.15: driver.find_element_by_xpath(\"//a[@rel='q4_4']\").click()elif 0.15 &lt; q4 &lt;= 0.30: driver.find_element_by_xpath(\"//a[@rel='q4_6']\").click()elif 0.30 &lt; q4 &lt;= 0.45: driver.find_element_by_xpath(\"//a[@rel='q4_8']\").click()elif 0.45 &lt; q4 &lt;= 0.60: driver.find_element_by_xpath(\"//a[@rel='q4_9']\").click()elif 0.45 &lt; q4 &lt;= 0.60: driver.find_element_by_xpath(\"//a[@rel='q4_10']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q4_11']\").click()# 处理Q5# 生成随机数，决定点哪个按钮q5 = random()if 0 &lt;= q5 &lt;= 0.25: driver.find_element_by_xpath(\"//a[@rel='q5_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_3']\").click()elif 0.25 &lt; q5 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q5_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_4']\").click()elif 0.50 &lt; q5 &lt;= 0.75: driver.find_element_by_xpath(\"//a[@rel='q5_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_4']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q5_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q5_4']\").click()# 处理Q6# 生成随机数，决定点哪个按钮q6 = random()if 0 &lt;= q6 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q6_2']\").click()elif 0.50 &lt; q6 &lt;= 0.60: driver.find_element_by_xpath(\"//a[@rel='q6_1']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q6_3']\").click()# 处理Q7# 生成随机数，决定点哪个按钮q7 = random()if 0 &lt;= q7 &lt;= 0.95: driver.find_element_by_xpath(\"//a[@rel='q7_1']\").click()elif 0.95 &lt; q7 &lt;= 0.98: driver.find_element_by_xpath(\"//a[@rel='q7_2']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q7_3']\").click()# 处理Q8# 生成随机数，决定点哪个按钮q8 = random()if 0 &lt;= q8 &lt;= 0.20: driver.find_element_by_xpath(\"//a[@rel='q8_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_4']\").click()elif 0.20 &lt; q8 &lt;= 0.40: driver.find_element_by_xpath(\"//a[@rel='q8_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_5']\").click()elif 0.20 &lt; q8 &lt;= 0.40: driver.find_element_by_xpath(\"//a[@rel='q8_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_4']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_5']\").click()elif 0.20 &lt; q8 &lt;= 0.40: driver.find_element_by_xpath(\"//a[@rel='q8_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_4']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_5']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q8_1']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_2']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_3']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_4']\").click() driver.find_element_by_xpath(\"//a[@rel='q8_5']\").click()# 处理Q9# 生成随机数，决定点哪个按钮q9 = random()driver.find_element_by_xpath(\"//a[@rel='q9_1']\").click()driver.find_element_by_xpath(\"//a[@rel='q9_3']\").click()driver.find_element_by_xpath(\"//a[@rel='q9_4']\").click()driver.find_element_by_xpath(\"//a[@rel='q9_5']\").click()driver.find_element_by_xpath(\"//a[@rel='q9_7']\").click()if 0 &lt;= q9 &lt;= 0.33: driver.find_element_by_xpath(\"//a[@rel='q9_2']\").click()elif 0.33 &lt; q9 &lt;= 0.66: driver.find_element_by_xpath(\"//a[@rel='q9_6']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q9_8']\").click()# 处理Q10# 生成随机数，决定点哪个按钮q10 = random()driver.find_element_by_xpath(\"//a[@rel='q10_2']\").click()driver.find_element_by_xpath(\"//a[@rel='q10_4']\").click()if 0 &lt;= q10 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q10_3']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q10_1']\").click()# 处理Q11# 生成随机数，决定点哪个按钮q11 = random()driver.find_element_by_xpath(\"//a[@rel='q11_1']\").click()driver.find_element_by_xpath(\"//a[@rel='q11_2']\").click()driver.find_element_by_xpath(\"//a[@rel='q11_3']\").click()if 0 &lt;= q11 &lt;= 0.25: driver.find_element_by_xpath(\"//a[@rel='q11_4']\").click()elif 0.25 &lt; q9 &lt;= 0.50: driver.find_element_by_xpath(\"//a[@rel='q11_5']\").click()elif 0.50 &lt; q9 &lt;= 0.75: driver.find_element_by_xpath(\"//a[@rel='q11_6']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q11_7']\").click()# 处理Q12# 生成随机数，决定点哪个按钮q12 = random()if 0 &lt;= q12 &lt;= 0.85: driver.find_element_by_xpath(\"//a[@rel='q12_1']\").click()elif 0.85 &lt; q12 &lt;= 0.95: driver.find_element_by_xpath(\"//a[@rel='q12_2']\").click()else: driver.find_element_by_xpath(\"//a[@rel='q12_3']\").click()# 处理Q13driver.find_element_by_xpath(\"//a[@rel='q13_1']\").click()driver.find_element_by_xpath(\"//a[@rel='q13_2']\").click()driver.find_element_by_xpath(\"//a[@rel='q13_3']\").click()# 模拟点击提交按钮driver.find_element_by_xpath(\"//input[@value='提交']\").click()time.sleep(0.5)# 模拟点击智能验证按钮# 先点确认driver.find_element_by_xpath(\"//button[text()='确认']\").click()# 再点智能验证提示框，进行智能验证driver.find_element_by_xpath(\"//div[@id='captcha']\").click() 上述代码亲测可用。注意：当短时间内刷的问卷数过多时，可能会出现第二重智能验证，要拖动滑块进行验证，这个我暂时没有进行实验。 代码验证视频：","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"selenium","slug":"selenium","permalink":"http://silence-tang.github.io/tags/selenium/"},{"name":"爬虫","slug":"爬虫","permalink":"http://silence-tang.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"一文掌握Python数据分析入门操作","slug":"一文掌握Python数据分析入门操作","date":"2021-09-06T11:39:00.000Z","updated":"2021-09-06T11:52:59.630Z","comments":true,"path":"2021/09/06/一文掌握Python数据分析入门操作/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/%E4%B8%80%E6%96%87%E6%8E%8C%E6%8F%A1Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/","excerpt":"这是一篇介绍用Python进行基础的数据分析的文章，总结了其他博主文章的要点，主要分为6个部分：1.生成或导入数据表2.检查数据表3.清洗数据表4.数据预处理5.数据汇总 | 数据统计 | 数据导出6.自动化处理","text":"这是一篇介绍用Python进行基础的数据分析的文章，总结了其他博主文章的要点，主要分为6个部分：1.生成或导入数据表2.检查数据表3.清洗数据表4.数据预处理5.数据汇总 | 数据统计 | 数据导出6.自动化处理 1.生成或导入数据表在使用 python 进行数据导入前，我们需要先导入 pandas 和 numpy 库。 12import numpy as npimport pandas as pd 导入数据表（从csv/xlsx文件导入）： 123df = pd.DataFrame(pd.read_csv('xxx.csv',header=1))df = pd.DataFrame(pd.read_excel('xxx.xlsx'))# df是dataframe的简写 生成数据表 12345678# 列属性名columns以list形式给出，np.nan是NaN空值df = pd.DataFrame({'id': [20001,20002,20003,20004,20005,20006,20007], 'date': pd.date_range('20210901', periods = 7), 'city': ['Beijing ', 'SH', ' guangzhou ', 'Shenzhen', 'shanghai', 'BEIJING ', 'SUZHOU'], 'age': [21,45,25,34,31,27,42], 'class': ['400-G','500-A','280-D','320-C','210-A','470-F','250-F'], 'salary': [15600,np.nan,34800,21000,np.nan,9500,np.nan]}, columns = ['id','date','city','age','class','salary']) 打印刚才生成的数据表 123456# 打印数据表print('数据表内容如下：')print(df)# 打印数据表某一列print('数据表的city列内容如下：')print(df['city']) 结果： 2.检查数据表输出表维度及基本信息 1234567# 数据维度(6, 6)print('数据表维度为：')print(df.shape)# 打印数据表信息print('数据表基本信息如下：')print(df.info()) 结果：显示表中数据的基本信息如数据类型，空值个数，占用空间大小等输出数据表的全部列名称 1234# 输出数据表的全部列名称print('数据表的全部列名称如下：')# 强制转化为列表形式print(list(df.columns)) 结果:检查数据表的空值和唯一值 1234567891011# 检查数据表是否存在空值print('数据表空值判断如下：')print(df.isnull())# 检查数据表某一列是否存在空值print('数据表的salary列空值判断如下：')print(df['salary'].isnull())# 输出数据表某一列的唯一值print('数据表的city列唯一值如下：')print(df['city'].unique()) 结果：查看数据表全部数值（以二维列表的形式返回） 123# 查看数据表数值,Python中的Values函数用来查看数据表中的数值,以二维列表的形式返回print('数据表的全部数值内容如下：')print(df.values) 结果：查看数据表部分行的数据 1234567# 查看前4行数据print('数据表的前4行内容如下：')print(df.head(4))# 查看后4行数据print('数据表的后4行内容如下：')print(df.tail(4)) 结果： 3.清洗数据表清理存在空值的行 12345# 删除数据表中含有空值的行,返回一个不含空值的数据框# 这里的删除并不是对原数据框操作，而是相当于对一个copy的数据框进行删除，所以需要把结果传给新数据框df1df1 = df.dropna(how = 'any')print('df删除所有存在空值的行后的新数据框为：')print(df1) 结果：空值的均值填充 123456# 使用salary列的均值去填充salary列空值# inplace = True表示直接对原数据框操作# 此时，不能将fillna语句结果赋值给新数据框df['salary'].fillna(df['salary'].mean(), inplace = True)print('df填充空值后的结果为：')print(df) 结果：删除某一列中所有字符中的空格以及单词的大小写替换 123456789# 清除city列中所有字符中的空格df['city'] = df['city'].map(str.strip)print('df清除city列中所有字符中的空格后的结果为：')print(df)# 将city列的所有字母转换为小写df['city'] = df['city'].str.lower()print('df的city列中所有字母转换为小写后的结果为：')print(df) 结果：某一列数据的类型转换 123456# 使用price列的均值去填充price列空值# inplace = True表示直接对原数据框操作# 此时，不能将fillna语句结果赋值给新数据框df['salary'].fillna(df['salary'].mean(), inplace = True)print('df填充空值后的结果为：')print(df) 结果：删除重复值所在行 1234# 删除重复值df['city'] = df['city'].drop_duplicates()print('df的city列删除重复值后的结果为：')print(df) 结果：替换数据值 12345# 数据替换df['city'] = df['city'].replace('sh', 'shanghai')df['city'] = df['city'].replace(NaN, 'nanjing')print('df的city列将sh替换为shanghai后的结果为：')print(df) 结果：更改列属性名称 1234# 更改列名称df = df.rename(columns={'class': 'category'})print('df更改class列名称后的结果为：')print(df) 结果： 4.数据预处理数据表的合并 123456789101112#创建 df1 数据表df1 = pd.DataFrame({\"id\": [20001,20002,20003,20004,20005,20006,20007], \"gender\": ['male','female','male','female','male','female','male'], \"pay\": ['Y','N','Y','Y','N','Y','N'], \"m-point\": [10,12,20,40,40,40,30]})print('df1为：')print(df1)# 数据表合并(df and df1)，how = 'inner'/'outer'/'left'/'right/df_inner = pd.merge(df, df1, how = 'inner')print('df和df1合并后的结果为：')print(df_inner) 结果：整张表按照某一列数据升序/降序排列 1234# 数据表按某两列排序(一个主序列，一个辅助序列，当主序列出现相等情况时，按辅助序列值升序排列)df_inner = df_inner.sort_values(by = ['age','salary'], ascending = True)print('df_inner按age列升序排列后的结果为：')print(df_inner) 结果：新建一列对某一列中符合条件的项进行标记 12345# 对符合条件的项进行标记# 如果salary列的值&gt;3000，group列显示high，否则显示lowdf_inner['group'] = np.where(df_inner['salary'] &gt; 20500, 'high', 'low')print('df_inner添加group列后的结果为：')print(df_inner) 新建一列对某一列中符合多个条件的数据进行标记 1234# 对符合多个条件的数据进行分组标记df_inner.loc[(df_inner['city'] == 'shenzhen') &amp; (df_inner['salary'] &gt;= 20000), 'flag'] = 1print('df_inner添加flag列后的结果为：')print(df_inner) 此时我们恢复数据表，按index升序排列 1234# 恢复一下按index升序排列df_inner = df_inner.sort_index()print('重新按index排序结果为：')print(df_inner) 按行或位置提取数据(loc iloc) 12345678910# 按数据表的--索引标签--提取数据(loc)df_part1 = df_inner.loc[0:3]print('提取结果为：')print(df_part1)# 按数据表的--位置--提取数据(iloc)# [0,2,5]表示所在行的位置，[4,5]表示所在列的位置df_part2 = df_inner.iloc[[0,2,5],[4,5]]print('提取结果为：')print(df_part2) 按条件筛选（与，或，非） 1234567891011# 按条件筛选（与，或，非）# 使用“与”条件进行筛选df_part3 = df_inner.loc[(df_inner['age'] &gt; 20) &amp; (df_inner['city'] == 'beijing'), ['id','city','age','gender','price']]print('提取结果为：')print(df_part3)# 使用“或”条件筛选df_part4 = df_inner.loc[(df_inner['age'] &gt; 35) | (df_inner['city'] == 'beijing'), ['id','city','age','gender','price']]print('提取结果为：')print(df_part4)print('total price = %d' % df_part4['price'].sum()) 5.数据汇总 | 数据统计 | 数据导出数据表描述性的宏观统计，输出每一列的计数、均值、标准差等 123456# 数据表描述性统计# describe函数是进行描述统计的函数，按列标签生成每列数据的总数，均值，标准差等数据# 下面的代码中对数据表进行描述统计，使用round函数设置结果显示的小数位，并对结果数据进行转置statistics_result = df_inner.describe().round(2).Tprint('数据表宏观统计结果为：')print(statistics_result) 输出标准差、协方差、相关系数、数据表各列之间的相关性分析 12345678910111213141516# 标准差print('price列的标准差为：%d' % df_inner['price'].std())# 协方差# 协方差可以反应两个变量的协同关系, 变化趋势是否一致，是同向还是方向变化# 两个字段间的协方差print('price列与m-point列之间的的协方差为：%d' % df_inner['price'].cov(df_inner['m-point']))# 相关系数# corr函数用来计算数据间的相关系数，可以单独对特定数据进行计算，也可以对整个数据表中各个列进行计算# 相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为无线性相关关系print('price列与m-point列的相关系数为：%f' % df_inner['price'].corr(df_inner['m-point']))# 数据表各列之间的相关性分析print('数据表各列之间的相关系数为：')print(df_inner.corr()) 输出至xlsx/csv 12345#输出到excel格式df_inner.to_excel('C:\\\\Users\\\\HP\\\\Desktop\\\\py_to_excel.xlsx', sheet_name='sheet1')#输出到CSV格式df_inner.to_csv('C:\\\\Users\\\\HP\\\\Desktop\\\\py_to_csv.csv') 6.自动化处理(将一些重复性的机械操作封装)例如把显示数据表基本信息的操作写入函数 12345678910111213#创建自定义函数def display_info(x): shape=x.shape types=x.dtypes colums=x.columns statistics_result = df_inner.describe().round(2).T print(\"数据维度:\\n\",shape) print(\"数据格式:\\n\",types) print(\"列名称:\\n\",colums) print(\"统计信息:\\n\",statistics_result)#调用自定义函数获取 df 数据表信息并输出结果display_info(df) 结果：","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"数据分析","slug":"数据分析","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"Python模拟登陆教务系统爬取成绩信息+绘制成绩分布图+导入MySQL","slug":"Python模拟登陆教务系统爬取成绩信息+绘制成绩分布图+导入MySQL","date":"2021-09-06T11:29:00.000Z","updated":"2021-09-06T11:52:37.301Z","comments":true,"path":"2021/09/06/Python模拟登陆教务系统爬取成绩信息+绘制成绩分布图+导入MySQL/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E4%BF%A1%E6%81%AF+%E7%BB%98%E5%88%B6%E6%88%90%E7%BB%A9%E5%88%86%E5%B8%83%E5%9B%BE+%E5%AF%BC%E5%85%A5MySQL/","excerpt":"这是一篇介绍如何通过Python实现模拟登陆学校教务系统并爬取成绩相关信息（学期,课程名,总成绩,课程性质,学分）然后绘制成绩分布折线图最后导入MySQL数据库中的文章。 为了利用充分利用selenium的功能和成功爬取数据，需要有前置的html、css、简单爬虫的相关知识。 说明：我学校的成绩查询页面是通过加载js框架进而动态实时加载显示表格及数据的，如果仅仅是用一般的爬虫方法直接爬取页面信息，是不能成功的，因为那样是直接获取网页源码，其中并没有成绩数据。当然，采用某些爬虫方法肯定也能实现爬取js动态网页，但是我为了简单起见，直接用了selenium模拟登陆系统然后爬取信息。","text":"这是一篇介绍如何通过Python实现模拟登陆学校教务系统并爬取成绩相关信息（学期,课程名,总成绩,课程性质,学分）然后绘制成绩分布折线图最后导入MySQL数据库中的文章。 为了利用充分利用selenium的功能和成功爬取数据，需要有前置的html、css、简单爬虫的相关知识。 说明：我学校的成绩查询页面是通过加载js框架进而动态实时加载显示表格及数据的，如果仅仅是用一般的爬虫方法直接爬取页面信息，是不能成功的，因为那样是直接获取网页源码，其中并没有成绩数据。当然，采用某些爬虫方法肯定也能实现爬取js动态网页，但是我为了简单起见，直接用了selenium模拟登陆系统然后爬取信息。 一、导入主要模块1234567from bs4 import BeautifulSoup from selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysimport matplotlib.pyplot as pltimport timeimport pymysql 二、利用selenium模拟登陆教务系统 1.首先给出系统登陆页面url和成绩查询页面url（方便登陆成功后直接跳转，省去了鼠标点击相关链接的操作） 123# 给出所需的urlurl_login_page = (\"你学校的教务系统登录页面url\")url_cjcx=(\"成绩查询页面url\") 2.打开系统登录页面 12345678# 启动Chorme驱动，开始模拟（不能用静默模式启动）option = webdriver.ChromeOptions()# 不加载图片，提高访问速度option.add_argument('blink-settings=imagesEnabled=false')driver = webdriver.Chrome(chrome_options=option)driver.maximize_window()print(\"正在访问......\")driver.get(url_login_page) 3.模拟输入账号密码并点击登陆按钮 这里需要你自己用F12去查看自己学校系统登陆页面的网页元素然后找到账号密码输入框、登录按钮的元素名称（这里我通过find_element_by_id找到了所需的输入框及按钮） 12345678# 自动输入账号密码driver.find_element_by_id(\"username\").send_keys(\"你的学号\")driver.find_element_by_id(\"password\").send_keys(\"你的密码\")# 找到并点击登录按钮，实现登录login_button = driver.find_element_by_id(\"login_submit\")actions = ActionChains(driver)actions.key_down(Keys.CONTROL).click(login_button).key_up(Keys.CONTROL).perform() 三、爬取成绩信息 1.在新页面打开成绩查询页面 123# 打开新的地址driver.switch_to.window(driver.window_handles[-1])driver.get(url_cjcx) 2.等待成绩查询页面加载完毕我学校的查询页面与学校数据库对接较缓慢，所以我设置了10s等待时间，否则页面加载不出来会报错 12# 等待页面加载完毕time.sleep(10) 3.找到“每页显示50条数据”的按钮并点击这里我想点击“每页显示50条数据”按钮是因为这样可以直接爬取所有数据而不需要点击“下一页”按钮。同样地，这里根据个人需要调整参数即可 1234567# 找到每页显示数目选择框并点击\"50\"driver.find_element_by_class_name(\"bh-pull-right.jqx-widget.jqx-dropdownlist-state-normal.jqx-rc-all.jqx-fill-state-normal\").click()time.sleep(0.5)driver.find_element_by_xpath(\"//span[text()='50']\").click()# 等待页面加载完毕time.sleep(1) 4.爬取成绩查询页面的信息这里采用的方法是先用driver.page_source+BeautifulSoup的方法获取当前页面的源码然后采用一般的爬虫方法获取相关信息 123456789101112131415161718192021222324252627282930313233343536373839# 准备爬取成绩查询页面的信息data = driver.page_sourcesoup = BeautifulSoup(data, 'lxml')trs = soup.find_all(\"tr\")total_container = []for tr in trs: row_container = [] for span in tr: row_container.append(span.string) total_container.append(row_container)# 初始化score subjects列表score = []subjects = []# 输出最近两学期成绩数据print(\"近两学期所有科目成绩如下：\")subject_num = int(len(total_container)/2)for i in range(1,subject_num+1): print(total_container[i-1][1], total_container[i-1][2], total_container[i-1][6], total_container[i-1][9], total_container[i-1][11]) subjects.append(total_container[i-1][2]) score.append(total_container[i-1][6])print(\"\\n原始成绩：\",score,\"\\n\")# 规范化成绩for i in range(1,subject_num+1): if score[i-1] == '优秀' or score[i-1] =='621': score[i-1] = 95 elif score[i-1] == '良好': score[i-1] = 85 elif score[i-1] == '通过': score[i-1] = 75 elif score[i-1] == None: score[i-1] = 98 else: score[i-1] = int(score[i-1])print(\"科目：\",subjects,\"\\n\")print(\"规范化后的成绩：\",score) 结果： 四、绘制成绩分布统计图 我们采用matplotlib.pyplot画图 123456789# 绘图print(\"\\n正在绘制成绩分布折线图...\")x = range(subject_num)# plt.xticks(x,subjects) # 可以设置坐标字plt.plot(x, score)plt.xlabel(\"Subject(The xth)\") #X轴标签plt.ylabel(\"Score\") #Y轴标签plt.title('Score Distribution Chart')plt.show() 结果： 五、将数据导入MySQL12345678910111213141516171819202122232425262728# 写入MySQLprint(\"\\n正在连接MySQL服务\\n...\")# 创建与测试数据库的连接conn = pymysql.connect(host='localhost',user=\"root\",password=\"你的密码\",database=\"score_db\")# 输出创建的连接对象的信息print(\"连接成功!\\n连接对象的基本信息如下：\")print (conn)print (type(conn))cursor = conn.cursor()print(\"开始向数据表插入爬取的内容...\")sql1 = (\"INSERT INTO score_table_test(学期,课程名,总成绩,课程性质,学分) VALUES(%s,%s,%s,%s,%s)\")for i in range(1,subject_num+1): # param中是实际的表格数据 param = (total_container[i-1][1], total_container[i-1][2], total_container[i-1][6], total_container[i-1][9], total_container[i-1][11]) cursor.execute(sql1, param) conn.commit()print(\"插入成功!\")# 清空表格内容print(\"正在清空当前表格内容...\")sql2 = (\"truncate table score_table_test\")cursor.execute(sql2)conn.commit()print(\"删除成功！\")# 关闭指针对象和连接对象print(\"准备断开数据库连接....\")cursor.close()conn.close()print(\"已成功断开连接！\") 结果：","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"selenium","slug":"selenium","permalink":"http://silence-tang.github.io/tags/selenium/"},{"name":"爬虫","slug":"爬虫","permalink":"http://silence-tang.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"MySQL","slug":"MySQL","permalink":"http://silence-tang.github.io/tags/MySQL/"}]},{"title":"Python构造代理ip池提高访问量","slug":"Python构造代理ip池提高访问量","date":"2021-09-06T11:16:00.000Z","updated":"2021-09-06T11:29:29.699Z","comments":true,"path":"2021/09/06/Python构造代理ip池提高访问量/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/Python%E6%9E%84%E9%80%A0%E4%BB%A3%E7%90%86ip%E6%B1%A0%E6%8F%90%E9%AB%98%E8%AE%BF%E9%97%AE%E9%87%8F/","excerpt":"这是一篇介绍如何用Python构造代理ip池+采用BeautifulSoup方法提高网页浏览量的文章。 一般情况下，网页统计访问量的方法是：若一段时间内用同一ip访问某网页，则该网页访问量只增加1。于是我们可以采用不同的代理ip每隔一段时间对服务器进行一次网页访问请求，以实现增加访问量的目的。 具体代码如下：","text":"这是一篇介绍如何用Python构造代理ip池+采用BeautifulSoup方法提高网页浏览量的文章。 一般情况下，网页统计访问量的方法是：若一段时间内用同一ip访问某网页，则该网页访问量只增加1。于是我们可以采用不同的代理ip每隔一段时间对服务器进行一次网页访问请求，以实现增加访问量的目的。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from bs4 import BeautifulSoupimport requestsimport randomimport timedef create_proxy_pool(): # 从西拉免费ip代理网站获取代理IP列表 r = requests.get('http://www.xiladaili.com/http/', headers= {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'}) # 返回解析得到的的html soup = BeautifulSoup(r.content, 'lxml') # 获取所有ip，构成ips列表 ips = soup.findAll('tr') # 初始化ip池空列表 proxy_pool = [] # 循环遍历ips列表 for i in range(1, len(ips)): # ip_row是ips中的行 ip_row = ips[i] # tds是每行中的属性值列表 tds = ip_row.findAll(\"td\") # 从一行中提取出proxy proxy = {'http':tds[0].get_text()} # 添加到代理池 proxy_pool.append(proxy) return proxy_pool# 代理客户端列表user_agents = [ \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\", \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\", \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\", \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\"]# 创建请求头信息def create_headers(): headers = dict() headers[\"User-Agent\"] = random.choice(user_agents) return headersdef startworking(): page1 = '网页url' # 调用请求头 # headers = create_headers() proxy_pool = create_proxy_pool() # print('请求头：%s' % headers) print('代理ip池：%s' % proxy_pool) # 循环构造并向服务器发送50次请求 for i in range(300): print('正在进行第%s次访问...' % i) # 从ip池中随机选择一个代理ip proxy = random.choice(proxy_pool) print('当前代理IP: %s' % proxy) # 等待60s,否则会被认为是同一次访问 sleep_time = 60 print('当前等待时间：%ds' % sleep_time) time.sleep(sleep_time) r = requests.get(url=page1, timeout=10, proxies=proxy, headers= {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'}) html = r.content soup = BeautifulSoup(html, \"lxml\") title = soup.find('h1') # 爬取文章的标题及当前访问量 read_count = soup.find('span', attrs={'class': 'read-count'}) print('文章标题：%s' % title.get_text()) print('当前文章访问量：%s\\n' % read_count.get_text())if __name__ =='__main__': startworking()","categories":[{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://silence-tang.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"B站清华数据挖掘笔记（二）——感知机&手推BP神经网络权重更新公式","slug":"B站清华数据挖掘笔记（二）——感知机&手推BP神经网络权重更新公式","date":"2021-09-06T02:40:00.000Z","updated":"2021-09-06T04:42:09.257Z","comments":true,"path":"2021/09/06/B站清华数据挖掘笔记（二）——感知机&手推BP神经网络权重更新公式/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%84%9F%E7%9F%A5%E6%9C%BA&%E6%89%8B%E6%8E%A8BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9D%83%E9%87%8D%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"http://silence-tang.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"感知机","slug":"感知机","permalink":"http://silence-tang.github.io/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/"}]},{"title":"B站清华数据挖掘笔记（一）——朴素贝叶斯&决策树","slug":"B站清华数据挖掘笔记（一）——朴素贝叶斯&决策树","date":"2021-09-06T02:30:00.000Z","updated":"2021-09-06T04:42:02.086Z","comments":true,"path":"2021/09/06/B站清华数据挖掘笔记（一）——朴素贝叶斯&决策树/","link":"","permalink":"http://silence-tang.github.io/2021/09/06/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF&%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"分类器","slug":"分类器","permalink":"http://silence-tang.github.io/tags/%E5%88%86%E7%B1%BB%E5%99%A8/"},{"name":"决策树","slug":"决策树","permalink":"http://silence-tang.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"http://silence-tang.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"B站清华数据挖掘笔记（三）——3类SVM支持向量机决策超平面的推导","slug":"B站清华数据挖掘笔记（三）——3类SVM支持向量机决策超平面的推导","date":"2021-09-05T14:12:00.000Z","updated":"2021-09-06T04:42:30.825Z","comments":true,"path":"2021/09/05/B站清华数据挖掘笔记（三）——3类SVM支持向量机决策超平面的推导/","link":"","permalink":"http://silence-tang.github.io/2021/09/05/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%943%E7%B1%BBSVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%86%B3%E7%AD%96%E8%B6%85%E5%B9%B3%E9%9D%A2%E7%9A%84%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://silence-tang.github.io/tags/SVM/"}]},{"title":"B站清华数据挖掘笔记（六）——集成学习（Bagging&AdaBoost）","slug":"B站清华数据挖掘笔记（六）——集成学习（Bagging&AdaBoost）","date":"2021-09-05T14:12:00.000Z","updated":"2021-09-06T04:43:05.986Z","comments":true,"path":"2021/09/05/B站清华数据挖掘笔记（六）——集成学习（Bagging&AdaBoost）/","link":"","permalink":"http://silence-tang.github.io/2021/09/05/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%EF%BC%88Bagging&AdaBoost%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"集成学习","slug":"集成学习","permalink":"http://silence-tang.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"http://silence-tang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Bagging","slug":"Bagging","permalink":"http://silence-tang.github.io/tags/Bagging/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"http://silence-tang.github.io/tags/AdaBoost/"}]},{"title":"B站清华数据挖掘笔记（五）——Apriori算法","slug":"B站清华数据挖掘笔记（五）——Apriori算法","date":"2021-09-05T14:12:00.000Z","updated":"2021-09-06T04:42:42.229Z","comments":true,"path":"2021/09/05/B站清华数据挖掘笔记（五）——Apriori算法/","link":"","permalink":"http://silence-tang.github.io/2021/09/05/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Apriori%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"Apriori","slug":"Apriori","permalink":"http://silence-tang.github.io/tags/Apriori/"}]},{"title":"B站清华数据挖掘笔记（四）——聚类（K-Means&层次聚类）","slug":"B站清华数据挖掘笔记（四）——聚类（K-Means&层次聚类）","date":"2021-09-05T14:12:00.000Z","updated":"2021-09-06T04:42:36.540Z","comments":true,"path":"2021/09/05/B站清华数据挖掘笔记（四）——聚类（K-Means&层次聚类）/","link":"","permalink":"http://silence-tang.github.io/2021/09/05/B%E7%AB%99%E6%B8%85%E5%8D%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%81%9A%E7%B1%BB%EF%BC%88K-Means&%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"聚类","slug":"聚类","permalink":"http://silence-tang.github.io/tags/%E8%81%9A%E7%B1%BB/"},{"name":"K-Means","slug":"K-Means","permalink":"http://silence-tang.github.io/tags/K-Means/"},{"name":"层次聚类","slug":"层次聚类","permalink":"http://silence-tang.github.io/tags/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/"}]},{"title":"Hello World —— 我的第一篇文章","slug":"Hello World —— 我的第一篇文章","date":"2021-09-04T13:30:42.373Z","updated":"2021-09-06T13:14:10.437Z","comments":true,"path":"2021/09/04/Hello World —— 我的第一篇文章/","link":"","permalink":"http://silence-tang.github.io/2021/09/04/Hello%20World%20%E2%80%94%E2%80%94%20%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","categories":[],"tags":[]}],"categories":[{"name":"HTML/CSS/MD","slug":"HTML-CSS-MD","permalink":"http://silence-tang.github.io/categories/HTML-CSS-MD/"},{"name":"计科课程学习","slug":"计科课程学习","permalink":"http://silence-tang.github.io/categories/%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Python学习-爬虫/数据分析/游戏制作","slug":"Python学习-爬虫-数据分析-游戏制作","permalink":"http://silence-tang.github.io/categories/Python%E5%AD%A6%E4%B9%A0-%E7%88%AC%E8%99%AB-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"},{"name":"数据挖掘","slug":"数据挖掘","permalink":"http://silence-tang.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://silence-tang.github.io/tags/HTML/"},{"name":"vs code","slug":"vs-code","permalink":"http://silence-tang.github.io/tags/vs-code/"},{"name":"Markdown","slug":"Markdown","permalink":"http://silence-tang.github.io/tags/Markdown/"},{"name":"经验分享","slug":"经验分享","permalink":"http://silence-tang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"操作系统","slug":"操作系统","permalink":"http://silence-tang.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://silence-tang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"http://silence-tang.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"模电","slug":"模电","permalink":"http://silence-tang.github.io/tags/%E6%A8%A1%E7%94%B5/"},{"name":"数字电路与逻辑设计","slug":"数字电路与逻辑设计","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"},{"name":"数学建模","slug":"数学建模","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"GitHub","slug":"GitHub","permalink":"http://silence-tang.github.io/tags/GitHub/"},{"name":"Python","slug":"Python","permalink":"http://silence-tang.github.io/tags/Python/"},{"name":"pygame","slug":"pygame","permalink":"http://silence-tang.github.io/tags/pygame/"},{"name":"爬虫","slug":"爬虫","permalink":"http://silence-tang.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"MySQL","slug":"MySQL","permalink":"http://silence-tang.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"selenium","slug":"selenium","permalink":"http://silence-tang.github.io/tags/selenium/"},{"name":"数据分析","slug":"数据分析","permalink":"http://silence-tang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"神经网络","slug":"神经网络","permalink":"http://silence-tang.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"感知机","slug":"感知机","permalink":"http://silence-tang.github.io/tags/%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"name":"分类器","slug":"分类器","permalink":"http://silence-tang.github.io/tags/%E5%88%86%E7%B1%BB%E5%99%A8/"},{"name":"决策树","slug":"决策树","permalink":"http://silence-tang.github.io/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"http://silence-tang.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"SVM","slug":"SVM","permalink":"http://silence-tang.github.io/tags/SVM/"},{"name":"集成学习","slug":"集成学习","permalink":"http://silence-tang.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"http://silence-tang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Bagging","slug":"Bagging","permalink":"http://silence-tang.github.io/tags/Bagging/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"http://silence-tang.github.io/tags/AdaBoost/"},{"name":"Apriori","slug":"Apriori","permalink":"http://silence-tang.github.io/tags/Apriori/"},{"name":"聚类","slug":"聚类","permalink":"http://silence-tang.github.io/tags/%E8%81%9A%E7%B1%BB/"},{"name":"K-Means","slug":"K-Means","permalink":"http://silence-tang.github.io/tags/K-Means/"},{"name":"层次聚类","slug":"层次聚类","permalink":"http://silence-tang.github.io/tags/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/"}]}